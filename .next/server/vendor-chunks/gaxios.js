"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/gaxios";
exports.ids = ["vendor-chunks/gaxios"];
exports.modules = {

/***/ "(rsc)/./node_modules/gaxios/build/src/common.js":
/*!*************************************************!*\
  !*** ./node_modules/gaxios/build/src/common.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2018 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultErrorRedactor = exports.GaxiosError = void 0;\nconst url_1 = __webpack_require__(/*! url */ \"url\");\n/* eslint-disable @typescript-eslint/no-explicit-any */\nclass GaxiosError extends Error {\n    constructor(message, config, response, error) {\n        super(message);\n        this.config = config;\n        this.response = response;\n        this.error = error;\n        if (this.response) {\n            try {\n                this.response.data = translateData(config.responseType, response === null || response === void 0 ? void 0 : response.data);\n            }\n            catch (_a) {\n                // best effort - don't throw an error within an error\n                // we could set `this.response.config.responseType = 'unknown'`, but\n                // that would mutate future calls with this config object.\n            }\n            this.status = this.response.status;\n        }\n        if (error && 'code' in error && error.code) {\n            this.code = error.code;\n        }\n        if (config.errorRedactor) {\n            const errorRedactor = (config.errorRedactor);\n            // shallow-copy config for redaction as we do not want\n            // future requests to have redacted information\n            this.config = { ...config };\n            if (this.response) {\n                // copy response's config, as it may be recursively redacted\n                this.response = { ...this.response, config: { ...this.response.config } };\n            }\n            const results = errorRedactor({ config, response });\n            this.config = { ...config, ...results.config };\n            if (this.response) {\n                this.response = { ...this.response, ...results.response, config };\n            }\n        }\n    }\n}\nexports.GaxiosError = GaxiosError;\nfunction translateData(responseType, data) {\n    switch (responseType) {\n        case 'stream':\n            return data;\n        case 'json':\n            return JSON.parse(JSON.stringify(data));\n        case 'arraybuffer':\n            return JSON.parse(Buffer.from(data).toString('utf8'));\n        case 'blob':\n            return JSON.parse(data.text());\n        default:\n            return data;\n    }\n}\n/**\n * An experimental error redactor.\n *\n * @param config Config to potentially redact properties of\n * @param response Config to potentially redact properties of\n *\n * @experimental\n */\nfunction defaultErrorRedactor(data) {\n    const REDACT = '<<REDACTED> - See `errorRedactor` option in `gaxios` for configuration>.';\n    function redactHeaders(headers) {\n        if (!headers)\n            return;\n        for (const key of Object.keys(headers)) {\n            // any casing of `Authentication`\n            if (/^authentication$/.test(key)) {\n                headers[key] = REDACT;\n            }\n        }\n    }\n    function redactString(obj, key) {\n        if (typeof obj === 'object' &&\n            obj !== null &&\n            typeof obj[key] === 'string') {\n            const text = obj[key];\n            if (/grant_type=/.test(text) || /assertion=/.test(text)) {\n                obj[key] = REDACT;\n            }\n        }\n    }\n    function redactObject(obj) {\n        if (typeof obj === 'object' && obj !== null) {\n            if ('grant_type' in obj) {\n                obj['grant_type'] = REDACT;\n            }\n            if ('assertion' in obj) {\n                obj['assertion'] = REDACT;\n            }\n        }\n    }\n    if (data.config) {\n        redactHeaders(data.config.headers);\n        redactString(data.config, 'data');\n        redactObject(data.config.data);\n        redactString(data.config, 'body');\n        redactObject(data.config.body);\n        try {\n            const url = new url_1.URL(data.config.url || '');\n            if (url.searchParams.has('token')) {\n                url.searchParams.set('token', REDACT);\n            }\n            data.config.url = url.toString();\n        }\n        catch (_a) {\n            // ignore error - no need to parse an invalid URL\n        }\n    }\n    if (data.response) {\n        defaultErrorRedactor({ config: data.response.config });\n        redactHeaders(data.response.headers);\n        redactString(data.response, 'data');\n        redactObject(data.response.data);\n    }\n    return data;\n}\nexports.defaultErrorRedactor = defaultErrorRedactor;\n//# sourceMappingURL=common.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL3NyYy9jb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsbUJBQW1CO0FBQ2xELGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0Esa0NBQWtDLDRCQUE0QjtBQUM5RDtBQUNBLDRDQUE0QyxrQkFBa0I7QUFDOUQsNEJBQTRCO0FBQzVCO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw4QkFBOEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dheGlvcy9idWlsZC9zcmMvY29tbW9uLmpzP2RiMmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdEVycm9yUmVkYWN0b3IgPSBleHBvcnRzLkdheGlvc0Vycm9yID0gdm9pZCAwO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuY2xhc3MgR2F4aW9zRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgY29uZmlnLCByZXNwb25zZSwgZXJyb3IpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgaWYgKHRoaXMucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZS5kYXRhID0gdHJhbnNsYXRlRGF0YShjb25maWcucmVzcG9uc2VUeXBlLCByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAvLyBiZXN0IGVmZm9ydCAtIGRvbid0IHRocm93IGFuIGVycm9yIHdpdGhpbiBhbiBlcnJvclxuICAgICAgICAgICAgICAgIC8vIHdlIGNvdWxkIHNldCBgdGhpcy5yZXNwb25zZS5jb25maWcucmVzcG9uc2VUeXBlID0gJ3Vua25vd24nYCwgYnV0XG4gICAgICAgICAgICAgICAgLy8gdGhhdCB3b3VsZCBtdXRhdGUgZnV0dXJlIGNhbGxzIHdpdGggdGhpcyBjb25maWcgb2JqZWN0LlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSB0aGlzLnJlc3BvbnNlLnN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgJ2NvZGUnIGluIGVycm9yICYmIGVycm9yLmNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZSA9IGVycm9yLmNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5lcnJvclJlZGFjdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvclJlZGFjdG9yID0gKGNvbmZpZy5lcnJvclJlZGFjdG9yKTtcbiAgICAgICAgICAgIC8vIHNoYWxsb3ctY29weSBjb25maWcgZm9yIHJlZGFjdGlvbiBhcyB3ZSBkbyBub3Qgd2FudFxuICAgICAgICAgICAgLy8gZnV0dXJlIHJlcXVlc3RzIHRvIGhhdmUgcmVkYWN0ZWQgaW5mb3JtYXRpb25cbiAgICAgICAgICAgIHRoaXMuY29uZmlnID0geyAuLi5jb25maWcgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgLy8gY29weSByZXNwb25zZSdzIGNvbmZpZywgYXMgaXQgbWF5IGJlIHJlY3Vyc2l2ZWx5IHJlZGFjdGVkXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IHsgLi4udGhpcy5yZXNwb25zZSwgY29uZmlnOiB7IC4uLnRoaXMucmVzcG9uc2UuY29uZmlnIH0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBlcnJvclJlZGFjdG9yKHsgY29uZmlnLCByZXNwb25zZSB9KTtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnID0geyAuLi5jb25maWcsIC4uLnJlc3VsdHMuY29uZmlnIH07XG4gICAgICAgICAgICBpZiAodGhpcy5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSB7IC4uLnRoaXMucmVzcG9uc2UsIC4uLnJlc3VsdHMucmVzcG9uc2UsIGNvbmZpZyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5HYXhpb3NFcnJvciA9IEdheGlvc0Vycm9yO1xuZnVuY3Rpb24gdHJhbnNsYXRlRGF0YShyZXNwb25zZVR5cGUsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3BvbnNlVHlwZSkge1xuICAgICAgICBjYXNlICdzdHJlYW0nOlxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgICAgICBjYXNlICdhcnJheWJ1ZmZlcic6XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShCdWZmZXIuZnJvbShkYXRhKS50b1N0cmluZygndXRmOCcpKTtcbiAgICAgICAgY2FzZSAnYmxvYic6XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhLnRleHQoKSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGV4cGVyaW1lbnRhbCBlcnJvciByZWRhY3Rvci5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIENvbmZpZyB0byBwb3RlbnRpYWxseSByZWRhY3QgcHJvcGVydGllcyBvZlxuICogQHBhcmFtIHJlc3BvbnNlIENvbmZpZyB0byBwb3RlbnRpYWxseSByZWRhY3QgcHJvcGVydGllcyBvZlxuICpcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZnVuY3Rpb24gZGVmYXVsdEVycm9yUmVkYWN0b3IoZGF0YSkge1xuICAgIGNvbnN0IFJFREFDVCA9ICc8PFJFREFDVEVEPiAtIFNlZSBgZXJyb3JSZWRhY3RvcmAgb3B0aW9uIGluIGBnYXhpb3NgIGZvciBjb25maWd1cmF0aW9uPi4nO1xuICAgIGZ1bmN0aW9uIHJlZGFjdEhlYWRlcnMoaGVhZGVycykge1xuICAgICAgICBpZiAoIWhlYWRlcnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgICAvLyBhbnkgY2FzaW5nIG9mIGBBdXRoZW50aWNhdGlvbmBcbiAgICAgICAgICAgIGlmICgvXmF1dGhlbnRpY2F0aW9uJC8udGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1trZXldID0gUkVEQUNUO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZGFjdFN0cmluZyhvYmosIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIG9iaiAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIG9ialtrZXldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IG9ialtrZXldO1xuICAgICAgICAgICAgaWYgKC9ncmFudF90eXBlPS8udGVzdCh0ZXh0KSB8fCAvYXNzZXJ0aW9uPS8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gUkVEQUNUO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZGFjdE9iamVjdChvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCdncmFudF90eXBlJyBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBvYmpbJ2dyYW50X3R5cGUnXSA9IFJFREFDVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnYXNzZXJ0aW9uJyBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBvYmpbJ2Fzc2VydGlvbiddID0gUkVEQUNUO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhLmNvbmZpZykge1xuICAgICAgICByZWRhY3RIZWFkZXJzKGRhdGEuY29uZmlnLmhlYWRlcnMpO1xuICAgICAgICByZWRhY3RTdHJpbmcoZGF0YS5jb25maWcsICdkYXRhJyk7XG4gICAgICAgIHJlZGFjdE9iamVjdChkYXRhLmNvbmZpZy5kYXRhKTtcbiAgICAgICAgcmVkYWN0U3RyaW5nKGRhdGEuY29uZmlnLCAnYm9keScpO1xuICAgICAgICByZWRhY3RPYmplY3QoZGF0YS5jb25maWcuYm9keSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgdXJsXzEuVVJMKGRhdGEuY29uZmlnLnVybCB8fCAnJyk7XG4gICAgICAgICAgICBpZiAodXJsLnNlYXJjaFBhcmFtcy5oYXMoJ3Rva2VuJykpIHtcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgndG9rZW4nLCBSRURBQ1QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YS5jb25maWcudXJsID0gdXJsLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3IgLSBubyBuZWVkIHRvIHBhcnNlIGFuIGludmFsaWQgVVJMXG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRhdGEucmVzcG9uc2UpIHtcbiAgICAgICAgZGVmYXVsdEVycm9yUmVkYWN0b3IoeyBjb25maWc6IGRhdGEucmVzcG9uc2UuY29uZmlnIH0pO1xuICAgICAgICByZWRhY3RIZWFkZXJzKGRhdGEucmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgIHJlZGFjdFN0cmluZyhkYXRhLnJlc3BvbnNlLCAnZGF0YScpO1xuICAgICAgICByZWRhY3RPYmplY3QoZGF0YS5yZXNwb25zZS5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5leHBvcnRzLmRlZmF1bHRFcnJvclJlZGFjdG9yID0gZGVmYXVsdEVycm9yUmVkYWN0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gaxios/build/src/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/gaxios/build/src/gaxios.js":
/*!*************************************************!*\
  !*** ./node_modules/gaxios/build/src/gaxios.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Copyright 2018 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Gaxios = void 0;\nconst extend_1 = __importDefault(__webpack_require__(/*! extend */ \"(rsc)/./node_modules/extend/index.js\"));\nconst https_1 = __webpack_require__(/*! https */ \"https\");\nconst node_fetch_1 = __importDefault(__webpack_require__(/*! node-fetch */ \"(rsc)/./node_modules/node-fetch/lib/index.mjs\"));\nconst querystring_1 = __importDefault(__webpack_require__(/*! querystring */ \"querystring\"));\nconst is_stream_1 = __importDefault(__webpack_require__(/*! is-stream */ \"(rsc)/./node_modules/is-stream/index.js\"));\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst common_1 = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/gaxios/build/src/common.js\");\nconst retry_1 = __webpack_require__(/*! ./retry */ \"(rsc)/./node_modules/gaxios/build/src/retry.js\");\nconst https_proxy_agent_1 = __webpack_require__(/*! https-proxy-agent */ \"(rsc)/./node_modules/https-proxy-agent/dist/index.js\");\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fetch = hasFetch() ? window.fetch : node_fetch_1.default;\nfunction hasWindow() {\n    return typeof window !== 'undefined' && !!window;\n}\nfunction hasFetch() {\n    return hasWindow() && !!window.fetch;\n}\nfunction hasBuffer() {\n    return typeof Buffer !== 'undefined';\n}\nfunction hasHeader(options, header) {\n    return !!getHeader(options, header);\n}\nfunction getHeader(options, header) {\n    header = header.toLowerCase();\n    for (const key of Object.keys((options === null || options === void 0 ? void 0 : options.headers) || {})) {\n        if (header === key.toLowerCase()) {\n            return options.headers[key];\n        }\n    }\n    return undefined;\n}\nlet HttpsProxyAgent;\nfunction loadProxy() {\n    var _a, _b, _c, _d;\n    const proxy = ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.HTTPS_PROXY) ||\n        ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b.https_proxy) ||\n        ((_c = process === null || process === void 0 ? void 0 : process.env) === null || _c === void 0 ? void 0 : _c.HTTP_PROXY) ||\n        ((_d = process === null || process === void 0 ? void 0 : process.env) === null || _d === void 0 ? void 0 : _d.http_proxy);\n    if (proxy) {\n        HttpsProxyAgent = https_proxy_agent_1.HttpsProxyAgent;\n    }\n    return proxy;\n}\nloadProxy();\nfunction skipProxy(url) {\n    var _a;\n    const noProxyEnv = (_a = process.env.NO_PROXY) !== null && _a !== void 0 ? _a : process.env.no_proxy;\n    if (!noProxyEnv) {\n        return false;\n    }\n    const noProxyUrls = noProxyEnv.split(',');\n    const parsedURL = new url_1.URL(url);\n    return !!noProxyUrls.find(url => {\n        if (url.startsWith('*.') || url.startsWith('.')) {\n            url = url.replace(/^\\*\\./, '.');\n            return parsedURL.hostname.endsWith(url);\n        }\n        else {\n            return url === parsedURL.origin || url === parsedURL.hostname;\n        }\n    });\n}\n// Figure out if we should be using a proxy. Only if it's required, load\n// the https-proxy-agent module as it adds startup cost.\nfunction getProxy(url) {\n    // If there is a match between the no_proxy env variables and the url, then do not proxy\n    if (skipProxy(url)) {\n        return undefined;\n        // If there is not a match between the no_proxy env variables and the url, check to see if there should be a proxy\n    }\n    else {\n        return loadProxy();\n    }\n}\nclass Gaxios {\n    /**\n     * The Gaxios class is responsible for making HTTP requests.\n     * @param defaults The default set of options to be used for this instance.\n     */\n    constructor(defaults) {\n        this.agentCache = new Map();\n        this.defaults = defaults || {};\n    }\n    /**\n     * Perform an HTTP request with the given options.\n     * @param opts Set of HTTP options that will be used for this HTTP request.\n     */\n    async request(opts = {}) {\n        opts = this.validateOpts(opts);\n        return this._request(opts);\n    }\n    async _defaultAdapter(opts) {\n        const fetchImpl = opts.fetchImplementation || fetch;\n        const res = (await fetchImpl(opts.url, opts));\n        const data = await this.getResponseData(opts, res);\n        return this.translateResponse(opts, res, data);\n    }\n    /**\n     * Internal, retryable version of the `request` method.\n     * @param opts Set of HTTP options that will be used for this HTTP request.\n     */\n    async _request(opts = {}) {\n        try {\n            let translatedResponse;\n            if (opts.adapter) {\n                translatedResponse = await opts.adapter(opts, this._defaultAdapter.bind(this));\n            }\n            else {\n                translatedResponse = await this._defaultAdapter(opts);\n            }\n            if (!opts.validateStatus(translatedResponse.status)) {\n                if (opts.responseType === 'stream') {\n                    let response = '';\n                    await new Promise(resolve => {\n                        (translatedResponse === null || translatedResponse === void 0 ? void 0 : translatedResponse.data).on('data', chunk => {\n                            response += chunk;\n                        });\n                        (translatedResponse === null || translatedResponse === void 0 ? void 0 : translatedResponse.data).on('end', resolve);\n                    });\n                    translatedResponse.data = response;\n                }\n                throw new common_1.GaxiosError(`Request failed with status code ${translatedResponse.status}`, opts, translatedResponse);\n            }\n            return translatedResponse;\n        }\n        catch (e) {\n            const err = e instanceof common_1.GaxiosError\n                ? e\n                : new common_1.GaxiosError(e.message, opts, undefined, e);\n            const { shouldRetry, config } = await (0, retry_1.getRetryConfig)(err);\n            if (shouldRetry && config) {\n                err.config.retryConfig.currentRetryAttempt =\n                    config.retryConfig.currentRetryAttempt;\n                return this._request(err.config);\n            }\n            throw err;\n        }\n    }\n    async getResponseData(opts, res) {\n        switch (opts.responseType) {\n            case 'stream':\n                return res.body;\n            case 'json': {\n                let data = await res.text();\n                try {\n                    data = JSON.parse(data);\n                }\n                catch (_a) {\n                    // continue\n                }\n                return data;\n            }\n            case 'arraybuffer':\n                return res.arrayBuffer();\n            case 'blob':\n                return res.blob();\n            case 'text':\n                return res.text();\n            default:\n                return this.getResponseDataFromContentType(res);\n        }\n    }\n    /**\n     * Validates the options, and merges them with defaults.\n     * @param opts The original options passed from the client.\n     */\n    validateOpts(options) {\n        const opts = (0, extend_1.default)(true, {}, this.defaults, options);\n        if (!opts.url) {\n            throw new Error('URL is required.');\n        }\n        // baseUrl has been deprecated, remove in 2.0\n        const baseUrl = opts.baseUrl || opts.baseURL;\n        if (baseUrl) {\n            opts.url = baseUrl + opts.url;\n        }\n        opts.paramsSerializer = opts.paramsSerializer || this.paramsSerializer;\n        if (opts.params && Object.keys(opts.params).length > 0) {\n            let additionalQueryParams = opts.paramsSerializer(opts.params);\n            if (additionalQueryParams.startsWith('?')) {\n                additionalQueryParams = additionalQueryParams.slice(1);\n            }\n            const prefix = opts.url.includes('?') ? '&' : '?';\n            opts.url = opts.url + prefix + additionalQueryParams;\n        }\n        if (typeof options.maxContentLength === 'number') {\n            opts.size = options.maxContentLength;\n        }\n        if (typeof options.maxRedirects === 'number') {\n            opts.follow = options.maxRedirects;\n        }\n        opts.headers = opts.headers || {};\n        if (opts.data) {\n            const isFormData = typeof FormData === 'undefined'\n                ? false\n                : (opts === null || opts === void 0 ? void 0 : opts.data) instanceof FormData;\n            if (is_stream_1.default.readable(opts.data)) {\n                opts.body = opts.data;\n            }\n            else if (hasBuffer() && Buffer.isBuffer(opts.data)) {\n                // Do not attempt to JSON.stringify() a Buffer:\n                opts.body = opts.data;\n                if (!hasHeader(opts, 'Content-Type')) {\n                    opts.headers['Content-Type'] = 'application/json';\n                }\n            }\n            else if (typeof opts.data === 'object') {\n                // If www-form-urlencoded content type has been set, but data is\n                // provided as an object, serialize the content using querystring:\n                if (!isFormData) {\n                    if (getHeader(opts, 'content-type') ===\n                        'application/x-www-form-urlencoded') {\n                        opts.body = opts.paramsSerializer(opts.data);\n                    }\n                    else {\n                        // } else if (!(opts.data instanceof FormData)) {\n                        if (!hasHeader(opts, 'Content-Type')) {\n                            opts.headers['Content-Type'] = 'application/json';\n                        }\n                        opts.body = JSON.stringify(opts.data);\n                    }\n                }\n            }\n            else {\n                opts.body = opts.data;\n            }\n        }\n        opts.validateStatus = opts.validateStatus || this.validateStatus;\n        opts.responseType = opts.responseType || 'unknown';\n        if (!opts.headers['Accept'] && opts.responseType === 'json') {\n            opts.headers['Accept'] = 'application/json';\n        }\n        opts.method = opts.method || 'GET';\n        const proxy = getProxy(opts.url);\n        if (proxy) {\n            if (this.agentCache.has(proxy)) {\n                opts.agent = this.agentCache.get(proxy);\n            }\n            else {\n                // Proxy is being used in conjunction with mTLS.\n                if (opts.cert && opts.key) {\n                    const parsedURL = new url_1.URL(proxy);\n                    opts.agent = new HttpsProxyAgent({\n                        port: parsedURL.port,\n                        host: parsedURL.host,\n                        protocol: parsedURL.protocol,\n                        cert: opts.cert,\n                        key: opts.key,\n                    });\n                }\n                else {\n                    opts.agent = new HttpsProxyAgent(proxy);\n                }\n                this.agentCache.set(proxy, opts.agent);\n            }\n        }\n        else if (opts.cert && opts.key) {\n            // Configure client for mTLS:\n            if (this.agentCache.has(opts.key)) {\n                opts.agent = this.agentCache.get(opts.key);\n            }\n            else {\n                opts.agent = new https_1.Agent({\n                    cert: opts.cert,\n                    key: opts.key,\n                });\n                this.agentCache.set(opts.key, opts.agent);\n            }\n        }\n        if (typeof opts.errorRedactor !== 'function' &&\n            opts.errorRedactor !== false) {\n            opts.errorRedactor = common_1.defaultErrorRedactor;\n        }\n        return opts;\n    }\n    /**\n     * By default, throw for any non-2xx status code\n     * @param status status code from the HTTP response\n     */\n    validateStatus(status) {\n        return status >= 200 && status < 300;\n    }\n    /**\n     * Encode a set of key/value pars into a querystring format (?foo=bar&baz=boo)\n     * @param params key value pars to encode\n     */\n    paramsSerializer(params) {\n        return querystring_1.default.stringify(params);\n    }\n    translateResponse(opts, res, data) {\n        // headers need to be converted from a map to an obj\n        const headers = {};\n        res.headers.forEach((value, key) => {\n            headers[key] = value;\n        });\n        return {\n            config: opts,\n            data: data,\n            headers,\n            status: res.status,\n            statusText: res.statusText,\n            // XMLHttpRequestLike\n            request: {\n                responseURL: res.url,\n            },\n        };\n    }\n    /**\n     * Attempts to parse a response by looking at the Content-Type header.\n     * @param {FetchResponse} response the HTTP response.\n     * @returns {Promise<any>} a promise that resolves to the response data.\n     */\n    async getResponseDataFromContentType(response) {\n        let contentType = response.headers.get('Content-Type');\n        if (contentType === null) {\n            // Maintain existing functionality by calling text()\n            return response.text();\n        }\n        contentType = contentType.toLowerCase();\n        if (contentType.includes('application/json')) {\n            let data = await response.text();\n            try {\n                data = JSON.parse(data);\n            }\n            catch (_a) {\n                // continue\n            }\n            return data;\n        }\n        else if (contentType.includes('text/plain') ||\n            contentType.includes('text/html')) {\n            return response.text();\n        }\n        else {\n            // If the content type is something not easily handled, just return the raw data (blob)\n            return response.blob();\n        }\n    }\n}\nexports.Gaxios = Gaxios;\n//# sourceMappingURL=gaxios.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL3NyYy9nYXhpb3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsaUNBQWlDLG1CQUFPLENBQUMsb0RBQVE7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMsb0JBQU87QUFDL0IscUNBQXFDLG1CQUFPLENBQUMsaUVBQVk7QUFDekQsc0NBQXNDLG1CQUFPLENBQUMsZ0NBQWE7QUFDM0Qsb0NBQW9DLG1CQUFPLENBQUMsMERBQVc7QUFDdkQsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLGlFQUFVO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLCtEQUFTO0FBQ2pDLDRCQUE0QixtQkFBTyxDQUFDLCtFQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esa0ZBQWtGLDBCQUEwQjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nYXhpb3MvYnVpbGQvc3JjL2dheGlvcy5qcz8wYTk0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdheGlvcyA9IHZvaWQgMDtcbmNvbnN0IGV4dGVuZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJleHRlbmRcIikpO1xuY29uc3QgaHR0cHNfMSA9IHJlcXVpcmUoXCJodHRwc1wiKTtcbmNvbnN0IG5vZGVfZmV0Y2hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibm9kZS1mZXRjaFwiKSk7XG5jb25zdCBxdWVyeXN0cmluZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKSk7XG5jb25zdCBpc19zdHJlYW1fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaXMtc3RyZWFtXCIpKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4vY29tbW9uXCIpO1xuY29uc3QgcmV0cnlfMSA9IHJlcXVpcmUoXCIuL3JldHJ5XCIpO1xuY29uc3QgaHR0cHNfcHJveHlfYWdlbnRfMSA9IHJlcXVpcmUoXCJodHRwcy1wcm94eS1hZ2VudFwiKTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmNvbnN0IGZldGNoID0gaGFzRmV0Y2goKSA/IHdpbmRvdy5mZXRjaCA6IG5vZGVfZmV0Y2hfMS5kZWZhdWx0O1xuZnVuY3Rpb24gaGFzV2luZG93KCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhIXdpbmRvdztcbn1cbmZ1bmN0aW9uIGhhc0ZldGNoKCkge1xuICAgIHJldHVybiBoYXNXaW5kb3coKSAmJiAhIXdpbmRvdy5mZXRjaDtcbn1cbmZ1bmN0aW9uIGhhc0J1ZmZlcigpIHtcbiAgICByZXR1cm4gdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBoYXNIZWFkZXIob3B0aW9ucywgaGVhZGVyKSB7XG4gICAgcmV0dXJuICEhZ2V0SGVhZGVyKG9wdGlvbnMsIGhlYWRlcik7XG59XG5mdW5jdGlvbiBnZXRIZWFkZXIob3B0aW9ucywgaGVhZGVyKSB7XG4gICAgaGVhZGVyID0gaGVhZGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKSB8fCB7fSkpIHtcbiAgICAgICAgaWYgKGhlYWRlciA9PT0ga2V5LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmhlYWRlcnNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxubGV0IEh0dHBzUHJveHlBZ2VudDtcbmZ1bmN0aW9uIGxvYWRQcm94eSgpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgY29uc3QgcHJveHkgPSAoKF9hID0gcHJvY2VzcyA9PT0gbnVsbCB8fCBwcm9jZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9jZXNzLmVudikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLkhUVFBTX1BST1hZKSB8fFxuICAgICAgICAoKF9iID0gcHJvY2VzcyA9PT0gbnVsbCB8fCBwcm9jZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9jZXNzLmVudikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmh0dHBzX3Byb3h5KSB8fFxuICAgICAgICAoKF9jID0gcHJvY2VzcyA9PT0gbnVsbCB8fCBwcm9jZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9jZXNzLmVudikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLkhUVFBfUFJPWFkpIHx8XG4gICAgICAgICgoX2QgPSBwcm9jZXNzID09PSBudWxsIHx8IHByb2Nlc3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2Nlc3MuZW52KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaHR0cF9wcm94eSk7XG4gICAgaWYgKHByb3h5KSB7XG4gICAgICAgIEh0dHBzUHJveHlBZ2VudCA9IGh0dHBzX3Byb3h5X2FnZW50XzEuSHR0cHNQcm94eUFnZW50O1xuICAgIH1cbiAgICByZXR1cm4gcHJveHk7XG59XG5sb2FkUHJveHkoKTtcbmZ1bmN0aW9uIHNraXBQcm94eSh1cmwpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgbm9Qcm94eUVudiA9IChfYSA9IHByb2Nlc3MuZW52Lk5PX1BST1hZKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwcm9jZXNzLmVudi5ub19wcm94eTtcbiAgICBpZiAoIW5vUHJveHlFbnYpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBub1Byb3h5VXJscyA9IG5vUHJveHlFbnYuc3BsaXQoJywnKTtcbiAgICBjb25zdCBwYXJzZWRVUkwgPSBuZXcgdXJsXzEuVVJMKHVybCk7XG4gICAgcmV0dXJuICEhbm9Qcm94eVVybHMuZmluZCh1cmwgPT4ge1xuICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJyouJykgfHwgdXJsLnN0YXJ0c1dpdGgoJy4nKSkge1xuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoL15cXCpcXC4vLCAnLicpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFVSTC5ob3N0bmFtZS5lbmRzV2l0aCh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVybCA9PT0gcGFyc2VkVVJMLm9yaWdpbiB8fCB1cmwgPT09IHBhcnNlZFVSTC5ob3N0bmFtZTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gRmlndXJlIG91dCBpZiB3ZSBzaG91bGQgYmUgdXNpbmcgYSBwcm94eS4gT25seSBpZiBpdCdzIHJlcXVpcmVkLCBsb2FkXG4vLyB0aGUgaHR0cHMtcHJveHktYWdlbnQgbW9kdWxlIGFzIGl0IGFkZHMgc3RhcnR1cCBjb3N0LlxuZnVuY3Rpb24gZ2V0UHJveHkodXJsKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYSBtYXRjaCBiZXR3ZWVuIHRoZSBub19wcm94eSBlbnYgdmFyaWFibGVzIGFuZCB0aGUgdXJsLCB0aGVuIGRvIG5vdCBwcm94eVxuICAgIGlmIChza2lwUHJveHkodXJsKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBub3QgYSBtYXRjaCBiZXR3ZWVuIHRoZSBub19wcm94eSBlbnYgdmFyaWFibGVzIGFuZCB0aGUgdXJsLCBjaGVjayB0byBzZWUgaWYgdGhlcmUgc2hvdWxkIGJlIGEgcHJveHlcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBsb2FkUHJveHkoKTtcbiAgICB9XG59XG5jbGFzcyBHYXhpb3Mge1xuICAgIC8qKlxuICAgICAqIFRoZSBHYXhpb3MgY2xhc3MgaXMgcmVzcG9uc2libGUgZm9yIG1ha2luZyBIVFRQIHJlcXVlc3RzLlxuICAgICAqIEBwYXJhbSBkZWZhdWx0cyBUaGUgZGVmYXVsdCBzZXQgb2Ygb3B0aW9ucyB0byBiZSB1c2VkIGZvciB0aGlzIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGRlZmF1bHRzKSB7XG4gICAgICAgIHRoaXMuYWdlbnRDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0cyA9IGRlZmF1bHRzIHx8IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIEhUVFAgcmVxdWVzdCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRzIFNldCBvZiBIVFRQIG9wdGlvbnMgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHRoaXMgSFRUUCByZXF1ZXN0LlxuICAgICAqL1xuICAgIGFzeW5jIHJlcXVlc3Qob3B0cyA9IHt9KSB7XG4gICAgICAgIG9wdHMgPSB0aGlzLnZhbGlkYXRlT3B0cyhvcHRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3Qob3B0cyk7XG4gICAgfVxuICAgIGFzeW5jIF9kZWZhdWx0QWRhcHRlcihvcHRzKSB7XG4gICAgICAgIGNvbnN0IGZldGNoSW1wbCA9IG9wdHMuZmV0Y2hJbXBsZW1lbnRhdGlvbiB8fCBmZXRjaDtcbiAgICAgICAgY29uc3QgcmVzID0gKGF3YWl0IGZldGNoSW1wbChvcHRzLnVybCwgb3B0cykpO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5nZXRSZXNwb25zZURhdGEob3B0cywgcmVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlUmVzcG9uc2Uob3B0cywgcmVzLCBkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwsIHJldHJ5YWJsZSB2ZXJzaW9uIG9mIHRoZSBgcmVxdWVzdGAgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBvcHRzIFNldCBvZiBIVFRQIG9wdGlvbnMgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHRoaXMgSFRUUCByZXF1ZXN0LlxuICAgICAqL1xuICAgIGFzeW5jIF9yZXF1ZXN0KG9wdHMgPSB7fSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHRyYW5zbGF0ZWRSZXNwb25zZTtcbiAgICAgICAgICAgIGlmIChvcHRzLmFkYXB0ZXIpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVkUmVzcG9uc2UgPSBhd2FpdCBvcHRzLmFkYXB0ZXIob3B0cywgdGhpcy5fZGVmYXVsdEFkYXB0ZXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVkUmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9kZWZhdWx0QWRhcHRlcihvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0cy52YWxpZGF0ZVN0YXR1cyh0cmFuc2xhdGVkUmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnJlc3BvbnNlVHlwZSA9PT0gJ3N0cmVhbScpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgKHRyYW5zbGF0ZWRSZXNwb25zZSA9PT0gbnVsbCB8fCB0cmFuc2xhdGVkUmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYW5zbGF0ZWRSZXNwb25zZS5kYXRhKS5vbignZGF0YScsIGNodW5rID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSArPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgKHRyYW5zbGF0ZWRSZXNwb25zZSA9PT0gbnVsbCB8fCB0cmFuc2xhdGVkUmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYW5zbGF0ZWRSZXNwb25zZS5kYXRhKS5vbignZW5kJywgcmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVkUmVzcG9uc2UuZGF0YSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29tbW9uXzEuR2F4aW9zRXJyb3IoYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJHt0cmFuc2xhdGVkUmVzcG9uc2Uuc3RhdHVzfWAsIG9wdHMsIHRyYW5zbGF0ZWRSZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRlZFJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBlIGluc3RhbmNlb2YgY29tbW9uXzEuR2F4aW9zRXJyb3JcbiAgICAgICAgICAgICAgICA/IGVcbiAgICAgICAgICAgICAgICA6IG5ldyBjb21tb25fMS5HYXhpb3NFcnJvcihlLm1lc3NhZ2UsIG9wdHMsIHVuZGVmaW5lZCwgZSk7XG4gICAgICAgICAgICBjb25zdCB7IHNob3VsZFJldHJ5LCBjb25maWcgfSA9IGF3YWl0ICgwLCByZXRyeV8xLmdldFJldHJ5Q29uZmlnKShlcnIpO1xuICAgICAgICAgICAgaWYgKHNob3VsZFJldHJ5ICYmIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIGVyci5jb25maWcucmV0cnlDb25maWcuY3VycmVudFJldHJ5QXR0ZW1wdCA9XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5yZXRyeUNvbmZpZy5jdXJyZW50UmV0cnlBdHRlbXB0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KGVyci5jb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFJlc3BvbnNlRGF0YShvcHRzLCByZXMpIHtcbiAgICAgICAgc3dpdGNoIChvcHRzLnJlc3BvbnNlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3RyZWFtJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmJvZHk7XG4gICAgICAgICAgICBjYXNlICdqc29uJzoge1xuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYXJyYXlidWZmZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXMuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2InOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXMuYmxvYigpO1xuICAgICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy50ZXh0KCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJlc3BvbnNlRGF0YUZyb21Db250ZW50VHlwZShyZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgb3B0aW9ucywgYW5kIG1lcmdlcyB0aGVtIHdpdGggZGVmYXVsdHMuXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIG9yaWdpbmFsIG9wdGlvbnMgcGFzc2VkIGZyb20gdGhlIGNsaWVudC5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZU9wdHMob3B0aW9ucykge1xuICAgICAgICBjb25zdCBvcHRzID0gKDAsIGV4dGVuZF8xLmRlZmF1bHQpKHRydWUsIHt9LCB0aGlzLmRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFvcHRzLnVybCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVUkwgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYmFzZVVybCBoYXMgYmVlbiBkZXByZWNhdGVkLCByZW1vdmUgaW4gMi4wXG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBvcHRzLmJhc2VVcmwgfHwgb3B0cy5iYXNlVVJMO1xuICAgICAgICBpZiAoYmFzZVVybCkge1xuICAgICAgICAgICAgb3B0cy51cmwgPSBiYXNlVXJsICsgb3B0cy51cmw7XG4gICAgICAgIH1cbiAgICAgICAgb3B0cy5wYXJhbXNTZXJpYWxpemVyID0gb3B0cy5wYXJhbXNTZXJpYWxpemVyIHx8IHRoaXMucGFyYW1zU2VyaWFsaXplcjtcbiAgICAgICAgaWYgKG9wdHMucGFyYW1zICYmIE9iamVjdC5rZXlzKG9wdHMucGFyYW1zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgYWRkaXRpb25hbFF1ZXJ5UGFyYW1zID0gb3B0cy5wYXJhbXNTZXJpYWxpemVyKG9wdHMucGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsUXVlcnlQYXJhbXMuc3RhcnRzV2l0aCgnPycpKSB7XG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbFF1ZXJ5UGFyYW1zID0gYWRkaXRpb25hbFF1ZXJ5UGFyYW1zLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gb3B0cy51cmwuaW5jbHVkZXMoJz8nKSA/ICcmJyA6ICc/JztcbiAgICAgICAgICAgIG9wdHMudXJsID0gb3B0cy51cmwgKyBwcmVmaXggKyBhZGRpdGlvbmFsUXVlcnlQYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1heENvbnRlbnRMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvcHRzLnNpemUgPSBvcHRpb25zLm1heENvbnRlbnRMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1heFJlZGlyZWN0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG9wdHMuZm9sbG93ID0gb3B0aW9ucy5tYXhSZWRpcmVjdHM7XG4gICAgICAgIH1cbiAgICAgICAgb3B0cy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICBpZiAob3B0cy5kYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBpc0Zvcm1EYXRhID0gdHlwZW9mIEZvcm1EYXRhID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuZGF0YSkgaW5zdGFuY2VvZiBGb3JtRGF0YTtcbiAgICAgICAgICAgIGlmIChpc19zdHJlYW1fMS5kZWZhdWx0LnJlYWRhYmxlKG9wdHMuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBvcHRzLmJvZHkgPSBvcHRzLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNCdWZmZXIoKSAmJiBCdWZmZXIuaXNCdWZmZXIob3B0cy5kYXRhKSkge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBhdHRlbXB0IHRvIEpTT04uc3RyaW5naWZ5KCkgYSBCdWZmZXI6XG4gICAgICAgICAgICAgICAgb3B0cy5ib2R5ID0gb3B0cy5kYXRhO1xuICAgICAgICAgICAgICAgIGlmICghaGFzSGVhZGVyKG9wdHMsICdDb250ZW50LVR5cGUnKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRzLmRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd3d3LWZvcm0tdXJsZW5jb2RlZCBjb250ZW50IHR5cGUgaGFzIGJlZW4gc2V0LCBidXQgZGF0YSBpc1xuICAgICAgICAgICAgICAgIC8vIHByb3ZpZGVkIGFzIGFuIG9iamVjdCwgc2VyaWFsaXplIHRoZSBjb250ZW50IHVzaW5nIHF1ZXJ5c3RyaW5nOlxuICAgICAgICAgICAgICAgIGlmICghaXNGb3JtRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0SGVhZGVyKG9wdHMsICdjb250ZW50LXR5cGUnKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzLmJvZHkgPSBvcHRzLnBhcmFtc1NlcmlhbGl6ZXIob3B0cy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIH0gZWxzZSBpZiAoIShvcHRzLmRhdGEgaW5zdGFuY2VvZiBGb3JtRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzSGVhZGVyKG9wdHMsICdDb250ZW50LVR5cGUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzLmJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRzLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0cy5ib2R5ID0gb3B0cy5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9wdHMudmFsaWRhdGVTdGF0dXMgPSBvcHRzLnZhbGlkYXRlU3RhdHVzIHx8IHRoaXMudmFsaWRhdGVTdGF0dXM7XG4gICAgICAgIG9wdHMucmVzcG9uc2VUeXBlID0gb3B0cy5yZXNwb25zZVR5cGUgfHwgJ3Vua25vd24nO1xuICAgICAgICBpZiAoIW9wdHMuaGVhZGVyc1snQWNjZXB0J10gJiYgb3B0cy5yZXNwb25zZVR5cGUgPT09ICdqc29uJykge1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJzWydBY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgfVxuICAgICAgICBvcHRzLm1ldGhvZCA9IG9wdHMubWV0aG9kIHx8ICdHRVQnO1xuICAgICAgICBjb25zdCBwcm94eSA9IGdldFByb3h5KG9wdHMudXJsKTtcbiAgICAgICAgaWYgKHByb3h5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hZ2VudENhY2hlLmhhcyhwcm94eSkpIHtcbiAgICAgICAgICAgICAgICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudENhY2hlLmdldChwcm94eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBQcm94eSBpcyBiZWluZyB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggbVRMUy5cbiAgICAgICAgICAgICAgICBpZiAob3B0cy5jZXJ0ICYmIG9wdHMua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFVSTCA9IG5ldyB1cmxfMS5VUkwocHJveHkpO1xuICAgICAgICAgICAgICAgICAgICBvcHRzLmFnZW50ID0gbmV3IEh0dHBzUHJveHlBZ2VudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiBwYXJzZWRVUkwucG9ydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHBhcnNlZFVSTC5ob3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2w6IHBhcnNlZFVSTC5wcm90b2NvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlcnQ6IG9wdHMuY2VydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogb3B0cy5rZXksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5hZ2VudCA9IG5ldyBIdHRwc1Byb3h5QWdlbnQocHJveHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFnZW50Q2FjaGUuc2V0KHByb3h5LCBvcHRzLmFnZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRzLmNlcnQgJiYgb3B0cy5rZXkpIHtcbiAgICAgICAgICAgIC8vIENvbmZpZ3VyZSBjbGllbnQgZm9yIG1UTFM6XG4gICAgICAgICAgICBpZiAodGhpcy5hZ2VudENhY2hlLmhhcyhvcHRzLmtleSkpIHtcbiAgICAgICAgICAgICAgICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudENhY2hlLmdldChvcHRzLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRzLmFnZW50ID0gbmV3IGh0dHBzXzEuQWdlbnQoe1xuICAgICAgICAgICAgICAgICAgICBjZXJ0OiBvcHRzLmNlcnQsXG4gICAgICAgICAgICAgICAgICAgIGtleTogb3B0cy5rZXksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZ2VudENhY2hlLnNldChvcHRzLmtleSwgb3B0cy5hZ2VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmVycm9yUmVkYWN0b3IgIT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIG9wdHMuZXJyb3JSZWRhY3RvciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG9wdHMuZXJyb3JSZWRhY3RvciA9IGNvbW1vbl8xLmRlZmF1bHRFcnJvclJlZGFjdG9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCB0aHJvdyBmb3IgYW55IG5vbi0yeHggc3RhdHVzIGNvZGVcbiAgICAgKiBAcGFyYW0gc3RhdHVzIHN0YXR1cyBjb2RlIGZyb20gdGhlIEhUVFAgcmVzcG9uc2VcbiAgICAgKi9cbiAgICB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGUgYSBzZXQgb2Yga2V5L3ZhbHVlIHBhcnMgaW50byBhIHF1ZXJ5c3RyaW5nIGZvcm1hdCAoP2Zvbz1iYXImYmF6PWJvbylcbiAgICAgKiBAcGFyYW0gcGFyYW1zIGtleSB2YWx1ZSBwYXJzIHRvIGVuY29kZVxuICAgICAqL1xuICAgIHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBxdWVyeXN0cmluZ18xLmRlZmF1bHQuc3RyaW5naWZ5KHBhcmFtcyk7XG4gICAgfVxuICAgIHRyYW5zbGF0ZVJlc3BvbnNlKG9wdHMsIHJlcywgZGF0YSkge1xuICAgICAgICAvLyBoZWFkZXJzIG5lZWQgdG8gYmUgY29udmVydGVkIGZyb20gYSBtYXAgdG8gYW4gb2JqXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmVzLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29uZmlnOiBvcHRzLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiByZXMuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIC8vIFhNTEh0dHBSZXF1ZXN0TGlrZVxuICAgICAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlVVJMOiByZXMudXJsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gcGFyc2UgYSByZXNwb25zZSBieSBsb29raW5nIGF0IHRoZSBDb250ZW50LVR5cGUgaGVhZGVyLlxuICAgICAqIEBwYXJhbSB7RmV0Y2hSZXNwb25zZX0gcmVzcG9uc2UgdGhlIEhUVFAgcmVzcG9uc2UuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlc3BvbnNlIGRhdGEuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UmVzcG9uc2VEYXRhRnJvbUNvbnRlbnRUeXBlKHJlc3BvbnNlKSB7XG4gICAgICAgIGxldCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKTtcbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBNYWludGFpbiBleGlzdGluZyBmdW5jdGlvbmFsaXR5IGJ5IGNhbGxpbmcgdGV4dCgpXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnRUeXBlID0gY29udGVudFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcygndGV4dC9wbGFpbicpIHx8XG4gICAgICAgICAgICBjb250ZW50VHlwZS5pbmNsdWRlcygndGV4dC9odG1sJykpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY29udGVudCB0eXBlIGlzIHNvbWV0aGluZyBub3QgZWFzaWx5IGhhbmRsZWQsIGp1c3QgcmV0dXJuIHRoZSByYXcgZGF0YSAoYmxvYilcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkdheGlvcyA9IEdheGlvcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdheGlvcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gaxios/build/src/gaxios.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/gaxios/build/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/gaxios/build/src/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2018 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.request = exports.instance = exports.Gaxios = exports.GaxiosError = void 0;\nconst gaxios_1 = __webpack_require__(/*! ./gaxios */ \"(rsc)/./node_modules/gaxios/build/src/gaxios.js\");\nObject.defineProperty(exports, \"Gaxios\", ({ enumerable: true, get: function () { return gaxios_1.Gaxios; } }));\nvar common_1 = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/gaxios/build/src/common.js\");\nObject.defineProperty(exports, \"GaxiosError\", ({ enumerable: true, get: function () { return common_1.GaxiosError; } }));\n/**\n * The default instance used when the `request` method is directly\n * invoked.\n */\nexports.instance = new gaxios_1.Gaxios();\n/**\n * Make an HTTP request using the given options.\n * @param opts Options for the request\n */\nasync function request(opts) {\n    return exports.instance.request(opts);\n}\nexports.request = request;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsZ0JBQWdCLEdBQUcsY0FBYyxHQUFHLG1CQUFtQjtBQUN6RSxpQkFBaUIsbUJBQU8sQ0FBQyxpRUFBVTtBQUNuQywwQ0FBeUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDNUcsZUFBZSxtQkFBTyxDQUFDLGlFQUFVO0FBQ2pDLCtDQUE4QyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nYXhpb3MvYnVpbGQvc3JjL2luZGV4LmpzPzdiN2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVxdWVzdCA9IGV4cG9ydHMuaW5zdGFuY2UgPSBleHBvcnRzLkdheGlvcyA9IGV4cG9ydHMuR2F4aW9zRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBnYXhpb3NfMSA9IHJlcXVpcmUoXCIuL2dheGlvc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkdheGlvc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2F4aW9zXzEuR2F4aW9zOyB9IH0pO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4vY29tbW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR2F4aW9zRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbW1vbl8xLkdheGlvc0Vycm9yOyB9IH0pO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBpbnN0YW5jZSB1c2VkIHdoZW4gdGhlIGByZXF1ZXN0YCBtZXRob2QgaXMgZGlyZWN0bHlcbiAqIGludm9rZWQuXG4gKi9cbmV4cG9ydHMuaW5zdGFuY2UgPSBuZXcgZ2F4aW9zXzEuR2F4aW9zKCk7XG4vKipcbiAqIE1ha2UgYW4gSFRUUCByZXF1ZXN0IHVzaW5nIHRoZSBnaXZlbiBvcHRpb25zLlxuICogQHBhcmFtIG9wdHMgT3B0aW9ucyBmb3IgdGhlIHJlcXVlc3RcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdChvcHRzKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuaW5zdGFuY2UucmVxdWVzdChvcHRzKTtcbn1cbmV4cG9ydHMucmVxdWVzdCA9IHJlcXVlc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gaxios/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/gaxios/build/src/retry.js":
/*!************************************************!*\
  !*** ./node_modules/gaxios/build/src/retry.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2018 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getRetryConfig = void 0;\nasync function getRetryConfig(err) {\n    var _a;\n    let config = getConfig(err);\n    if (!err || !err.config || (!config && !err.config.retry)) {\n        return { shouldRetry: false };\n    }\n    config = config || {};\n    config.currentRetryAttempt = config.currentRetryAttempt || 0;\n    config.retry =\n        config.retry === undefined || config.retry === null ? 3 : config.retry;\n    config.httpMethodsToRetry = config.httpMethodsToRetry || [\n        'GET',\n        'HEAD',\n        'PUT',\n        'OPTIONS',\n        'DELETE',\n    ];\n    config.noResponseRetries =\n        config.noResponseRetries === undefined || config.noResponseRetries === null\n            ? 2\n            : config.noResponseRetries;\n    // If this wasn't in the list of status codes where we want\n    // to automatically retry, return.\n    const retryRanges = [\n        // https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\n        // 1xx - Retry (Informational, request still processing)\n        // 2xx - Do not retry (Success)\n        // 3xx - Do not retry (Redirect)\n        // 4xx - Do not retry (Client errors)\n        // 429 - Retry (\"Too Many Requests\")\n        // 5xx - Retry (Server errors)\n        [100, 199],\n        [429, 429],\n        [500, 599],\n    ];\n    config.statusCodesToRetry = config.statusCodesToRetry || retryRanges;\n    // Put the config back into the err\n    err.config.retryConfig = config;\n    // Determine if we should retry the request\n    const shouldRetryFn = config.shouldRetry || shouldRetryRequest;\n    if (!(await shouldRetryFn(err))) {\n        return { shouldRetry: false, config: err.config };\n    }\n    // Calculate time to wait with exponential backoff.\n    // If this is the first retry, look for a configured retryDelay.\n    const retryDelay = config.currentRetryAttempt ? 0 : (_a = config.retryDelay) !== null && _a !== void 0 ? _a : 100;\n    // Formula: retryDelay + ((2^c - 1 / 2) * 1000)\n    const delay = retryDelay + ((Math.pow(2, config.currentRetryAttempt) - 1) / 2) * 1000;\n    // We're going to retry!  Incremenent the counter.\n    err.config.retryConfig.currentRetryAttempt += 1;\n    // Create a promise that invokes the retry after the backOffDelay\n    const backoff = config.retryBackoff\n        ? config.retryBackoff(err, delay)\n        : new Promise(resolve => {\n            setTimeout(resolve, delay);\n        });\n    // Notify the user if they added an `onRetryAttempt` handler\n    if (config.onRetryAttempt) {\n        config.onRetryAttempt(err);\n    }\n    // Return the promise in which recalls Gaxios to retry the request\n    await backoff;\n    return { shouldRetry: true, config: err.config };\n}\nexports.getRetryConfig = getRetryConfig;\n/**\n * Determine based on config if we should retry the request.\n * @param err The GaxiosError passed to the interceptor.\n */\nfunction shouldRetryRequest(err) {\n    var _a;\n    const config = getConfig(err);\n    // node-fetch raises an AbortError if signaled:\n    // https://github.com/bitinn/node-fetch#request-cancellation-with-abortsignal\n    if (err.name === 'AbortError' || ((_a = err.error) === null || _a === void 0 ? void 0 : _a.name) === 'AbortError') {\n        return false;\n    }\n    // If there's no config, or retries are disabled, return.\n    if (!config || config.retry === 0) {\n        return false;\n    }\n    // Check if this error has no response (ETIMEDOUT, ENOTFOUND, etc)\n    if (!err.response &&\n        (config.currentRetryAttempt || 0) >= config.noResponseRetries) {\n        return false;\n    }\n    // Only retry with configured HttpMethods.\n    if (!err.config.method ||\n        config.httpMethodsToRetry.indexOf(err.config.method.toUpperCase()) < 0) {\n        return false;\n    }\n    // If this wasn't in the list of status codes where we want\n    // to automatically retry, return.\n    if (err.response && err.response.status) {\n        let isInRange = false;\n        for (const [min, max] of config.statusCodesToRetry) {\n            const status = err.response.status;\n            if (status >= min && status <= max) {\n                isInRange = true;\n                break;\n            }\n        }\n        if (!isInRange) {\n            return false;\n        }\n    }\n    // If we are out of retry attempts, return\n    config.currentRetryAttempt = config.currentRetryAttempt || 0;\n    if (config.currentRetryAttempt >= config.retry) {\n        return false;\n    }\n    return true;\n}\n/**\n * Acquire the raxConfig object from an GaxiosError if available.\n * @param err The Gaxios error with a config object.\n */\nfunction getConfig(err) {\n    if (err && err.config && err.config.retryConfig) {\n        return err.config.retryConfig;\n    }\n    return;\n}\n//# sourceMappingURL=retry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2F4aW9zL2J1aWxkL3NyYy9yZXRyeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dheGlvcy9idWlsZC9zcmMvcmV0cnkuanM/OTI5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRSZXRyeUNvbmZpZyA9IHZvaWQgMDtcbmFzeW5jIGZ1bmN0aW9uIGdldFJldHJ5Q29uZmlnKGVycikge1xuICAgIHZhciBfYTtcbiAgICBsZXQgY29uZmlnID0gZ2V0Q29uZmlnKGVycik7XG4gICAgaWYgKCFlcnIgfHwgIWVyci5jb25maWcgfHwgKCFjb25maWcgJiYgIWVyci5jb25maWcucmV0cnkpKSB7XG4gICAgICAgIHJldHVybiB7IHNob3VsZFJldHJ5OiBmYWxzZSB9O1xuICAgIH1cbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgY29uZmlnLmN1cnJlbnRSZXRyeUF0dGVtcHQgPSBjb25maWcuY3VycmVudFJldHJ5QXR0ZW1wdCB8fCAwO1xuICAgIGNvbmZpZy5yZXRyeSA9XG4gICAgICAgIGNvbmZpZy5yZXRyeSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5yZXRyeSA9PT0gbnVsbCA/IDMgOiBjb25maWcucmV0cnk7XG4gICAgY29uZmlnLmh0dHBNZXRob2RzVG9SZXRyeSA9IGNvbmZpZy5odHRwTWV0aG9kc1RvUmV0cnkgfHwgW1xuICAgICAgICAnR0VUJyxcbiAgICAgICAgJ0hFQUQnLFxuICAgICAgICAnUFVUJyxcbiAgICAgICAgJ09QVElPTlMnLFxuICAgICAgICAnREVMRVRFJyxcbiAgICBdO1xuICAgIGNvbmZpZy5ub1Jlc3BvbnNlUmV0cmllcyA9XG4gICAgICAgIGNvbmZpZy5ub1Jlc3BvbnNlUmV0cmllcyA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5ub1Jlc3BvbnNlUmV0cmllcyA9PT0gbnVsbFxuICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICA6IGNvbmZpZy5ub1Jlc3BvbnNlUmV0cmllcztcbiAgICAvLyBJZiB0aGlzIHdhc24ndCBpbiB0aGUgbGlzdCBvZiBzdGF0dXMgY29kZXMgd2hlcmUgd2Ugd2FudFxuICAgIC8vIHRvIGF1dG9tYXRpY2FsbHkgcmV0cnksIHJldHVybi5cbiAgICBjb25zdCByZXRyeVJhbmdlcyA9IFtcbiAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9IVFRQX3N0YXR1c19jb2Rlc1xuICAgICAgICAvLyAxeHggLSBSZXRyeSAoSW5mb3JtYXRpb25hbCwgcmVxdWVzdCBzdGlsbCBwcm9jZXNzaW5nKVxuICAgICAgICAvLyAyeHggLSBEbyBub3QgcmV0cnkgKFN1Y2Nlc3MpXG4gICAgICAgIC8vIDN4eCAtIERvIG5vdCByZXRyeSAoUmVkaXJlY3QpXG4gICAgICAgIC8vIDR4eCAtIERvIG5vdCByZXRyeSAoQ2xpZW50IGVycm9ycylcbiAgICAgICAgLy8gNDI5IC0gUmV0cnkgKFwiVG9vIE1hbnkgUmVxdWVzdHNcIilcbiAgICAgICAgLy8gNXh4IC0gUmV0cnkgKFNlcnZlciBlcnJvcnMpXG4gICAgICAgIFsxMDAsIDE5OV0sXG4gICAgICAgIFs0MjksIDQyOV0sXG4gICAgICAgIFs1MDAsIDU5OV0sXG4gICAgXTtcbiAgICBjb25maWcuc3RhdHVzQ29kZXNUb1JldHJ5ID0gY29uZmlnLnN0YXR1c0NvZGVzVG9SZXRyeSB8fCByZXRyeVJhbmdlcztcbiAgICAvLyBQdXQgdGhlIGNvbmZpZyBiYWNrIGludG8gdGhlIGVyclxuICAgIGVyci5jb25maWcucmV0cnlDb25maWcgPSBjb25maWc7XG4gICAgLy8gRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCByZXRyeSB0aGUgcmVxdWVzdFxuICAgIGNvbnN0IHNob3VsZFJldHJ5Rm4gPSBjb25maWcuc2hvdWxkUmV0cnkgfHwgc2hvdWxkUmV0cnlSZXF1ZXN0O1xuICAgIGlmICghKGF3YWl0IHNob3VsZFJldHJ5Rm4oZXJyKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgc2hvdWxkUmV0cnk6IGZhbHNlLCBjb25maWc6IGVyci5jb25maWcgfTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIHRpbWUgdG8gd2FpdCB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmYuXG4gICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgcmV0cnksIGxvb2sgZm9yIGEgY29uZmlndXJlZCByZXRyeURlbGF5LlxuICAgIGNvbnN0IHJldHJ5RGVsYXkgPSBjb25maWcuY3VycmVudFJldHJ5QXR0ZW1wdCA/IDAgOiAoX2EgPSBjb25maWcucmV0cnlEZWxheSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTAwO1xuICAgIC8vIEZvcm11bGE6IHJldHJ5RGVsYXkgKyAoKDJeYyAtIDEgLyAyKSAqIDEwMDApXG4gICAgY29uc3QgZGVsYXkgPSByZXRyeURlbGF5ICsgKChNYXRoLnBvdygyLCBjb25maWcuY3VycmVudFJldHJ5QXR0ZW1wdCkgLSAxKSAvIDIpICogMTAwMDtcbiAgICAvLyBXZSdyZSBnb2luZyB0byByZXRyeSEgIEluY3JlbWVuZW50IHRoZSBjb3VudGVyLlxuICAgIGVyci5jb25maWcucmV0cnlDb25maWcuY3VycmVudFJldHJ5QXR0ZW1wdCArPSAxO1xuICAgIC8vIENyZWF0ZSBhIHByb21pc2UgdGhhdCBpbnZva2VzIHRoZSByZXRyeSBhZnRlciB0aGUgYmFja09mZkRlbGF5XG4gICAgY29uc3QgYmFja29mZiA9IGNvbmZpZy5yZXRyeUJhY2tvZmZcbiAgICAgICAgPyBjb25maWcucmV0cnlCYWNrb2ZmKGVyciwgZGVsYXkpXG4gICAgICAgIDogbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KTtcbiAgICAgICAgfSk7XG4gICAgLy8gTm90aWZ5IHRoZSB1c2VyIGlmIHRoZXkgYWRkZWQgYW4gYG9uUmV0cnlBdHRlbXB0YCBoYW5kbGVyXG4gICAgaWYgKGNvbmZpZy5vblJldHJ5QXR0ZW1wdCkge1xuICAgICAgICBjb25maWcub25SZXRyeUF0dGVtcHQoZXJyKTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIHRoZSBwcm9taXNlIGluIHdoaWNoIHJlY2FsbHMgR2F4aW9zIHRvIHJldHJ5IHRoZSByZXF1ZXN0XG4gICAgYXdhaXQgYmFja29mZjtcbiAgICByZXR1cm4geyBzaG91bGRSZXRyeTogdHJ1ZSwgY29uZmlnOiBlcnIuY29uZmlnIH07XG59XG5leHBvcnRzLmdldFJldHJ5Q29uZmlnID0gZ2V0UmV0cnlDb25maWc7XG4vKipcbiAqIERldGVybWluZSBiYXNlZCBvbiBjb25maWcgaWYgd2Ugc2hvdWxkIHJldHJ5IHRoZSByZXF1ZXN0LlxuICogQHBhcmFtIGVyciBUaGUgR2F4aW9zRXJyb3IgcGFzc2VkIHRvIHRoZSBpbnRlcmNlcHRvci5cbiAqL1xuZnVuY3Rpb24gc2hvdWxkUmV0cnlSZXF1ZXN0KGVycikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBjb25maWcgPSBnZXRDb25maWcoZXJyKTtcbiAgICAvLyBub2RlLWZldGNoIHJhaXNlcyBhbiBBYm9ydEVycm9yIGlmIHNpZ25hbGVkOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRpbm4vbm9kZS1mZXRjaCNyZXF1ZXN0LWNhbmNlbGxhdGlvbi13aXRoLWFib3J0c2lnbmFsXG4gICAgaWYgKGVyci5uYW1lID09PSAnQWJvcnRFcnJvcicgfHwgKChfYSA9IGVyci5lcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSdzIG5vIGNvbmZpZywgb3IgcmV0cmllcyBhcmUgZGlzYWJsZWQsIHJldHVybi5cbiAgICBpZiAoIWNvbmZpZyB8fCBjb25maWcucmV0cnkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiB0aGlzIGVycm9yIGhhcyBubyByZXNwb25zZSAoRVRJTUVET1VULCBFTk9URk9VTkQsIGV0YylcbiAgICBpZiAoIWVyci5yZXNwb25zZSAmJlxuICAgICAgICAoY29uZmlnLmN1cnJlbnRSZXRyeUF0dGVtcHQgfHwgMCkgPj0gY29uZmlnLm5vUmVzcG9uc2VSZXRyaWVzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gT25seSByZXRyeSB3aXRoIGNvbmZpZ3VyZWQgSHR0cE1ldGhvZHMuXG4gICAgaWYgKCFlcnIuY29uZmlnLm1ldGhvZCB8fFxuICAgICAgICBjb25maWcuaHR0cE1ldGhvZHNUb1JldHJ5LmluZGV4T2YoZXJyLmNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSkgPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gSWYgdGhpcyB3YXNuJ3QgaW4gdGhlIGxpc3Qgb2Ygc3RhdHVzIGNvZGVzIHdoZXJlIHdlIHdhbnRcbiAgICAvLyB0byBhdXRvbWF0aWNhbGx5IHJldHJ5LCByZXR1cm4uXG4gICAgaWYgKGVyci5yZXNwb25zZSAmJiBlcnIucmVzcG9uc2Uuc3RhdHVzKSB7XG4gICAgICAgIGxldCBpc0luUmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBbbWluLCBtYXhdIG9mIGNvbmZpZy5zdGF0dXNDb2Rlc1RvUmV0cnkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGVyci5yZXNwb25zZS5zdGF0dXM7XG4gICAgICAgICAgICBpZiAoc3RhdHVzID49IG1pbiAmJiBzdGF0dXMgPD0gbWF4KSB7XG4gICAgICAgICAgICAgICAgaXNJblJhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzSW5SYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHdlIGFyZSBvdXQgb2YgcmV0cnkgYXR0ZW1wdHMsIHJldHVyblxuICAgIGNvbmZpZy5jdXJyZW50UmV0cnlBdHRlbXB0ID0gY29uZmlnLmN1cnJlbnRSZXRyeUF0dGVtcHQgfHwgMDtcbiAgICBpZiAoY29uZmlnLmN1cnJlbnRSZXRyeUF0dGVtcHQgPj0gY29uZmlnLnJldHJ5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEFjcXVpcmUgdGhlIHJheENvbmZpZyBvYmplY3QgZnJvbSBhbiBHYXhpb3NFcnJvciBpZiBhdmFpbGFibGUuXG4gKiBAcGFyYW0gZXJyIFRoZSBHYXhpb3MgZXJyb3Igd2l0aCBhIGNvbmZpZyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGdldENvbmZpZyhlcnIpIHtcbiAgICBpZiAoZXJyICYmIGVyci5jb25maWcgJiYgZXJyLmNvbmZpZy5yZXRyeUNvbmZpZykge1xuICAgICAgICByZXR1cm4gZXJyLmNvbmZpZy5yZXRyeUNvbmZpZztcbiAgICB9XG4gICAgcmV0dXJuO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cnkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gaxios/build/src/retry.js\n");

/***/ })

};
;