"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/anser";
exports.ids = ["vendor-chunks/anser"];
exports.modules = {

/***/ "(ssr)/./node_modules/anser/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/anser/lib/index.js ***!
  \*****************************************/
/***/ ((module) => {

eval("\n\n// This file was originally written by @drudru (https://github.com/drudru/ansi_up), MIT, 2011\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ANSI_COLORS = [[{ color: \"0, 0, 0\", \"class\": \"ansi-black\" }, { color: \"187, 0, 0\", \"class\": \"ansi-red\" }, { color: \"0, 187, 0\", \"class\": \"ansi-green\" }, { color: \"187, 187, 0\", \"class\": \"ansi-yellow\" }, { color: \"0, 0, 187\", \"class\": \"ansi-blue\" }, { color: \"187, 0, 187\", \"class\": \"ansi-magenta\" }, { color: \"0, 187, 187\", \"class\": \"ansi-cyan\" }, { color: \"255,255,255\", \"class\": \"ansi-white\" }], [{ color: \"85, 85, 85\", \"class\": \"ansi-bright-black\" }, { color: \"255, 85, 85\", \"class\": \"ansi-bright-red\" }, { color: \"0, 255, 0\", \"class\": \"ansi-bright-green\" }, { color: \"255, 255, 85\", \"class\": \"ansi-bright-yellow\" }, { color: \"85, 85, 255\", \"class\": \"ansi-bright-blue\" }, { color: \"255, 85, 255\", \"class\": \"ansi-bright-magenta\" }, { color: \"85, 255, 255\", \"class\": \"ansi-bright-cyan\" }, { color: \"255, 255, 255\", \"class\": \"ansi-bright-white\" }]];\n\nvar Anser = function () {\n    _createClass(Anser, null, [{\n        key: \"escapeForHtml\",\n\n\n        /**\n         * Anser.escapeForHtml\n         * Escape the input HTML.\n         *\n         * This does the minimum escaping of text to make it compliant with HTML.\n         * In particular, the '&','<', and '>' characters are escaped. This should\n         * be run prior to `ansiToHtml`.\n         *\n         * @name Anser.escapeForHtml\n         * @function\n         * @param {String} txt The input text (containing the ANSI snippets).\n         * @returns {String} The escaped html.\n         */\n        value: function escapeForHtml(txt) {\n            return new Anser().escapeForHtml(txt);\n        }\n\n        /**\n         * Anser.linkify\n         * Adds the links in the HTML.\n         *\n         * This replaces any links in the text with anchor tags that display the\n         * link. The links should have at least one whitespace character\n         * surrounding it. Also, you should apply this after you have run\n         * `ansiToHtml` on the text.\n         *\n         * @name Anser.linkify\n         * @function\n         * @param {String} txt The input text.\n         * @returns {String} The HTML containing the <a> tags (unescaped).\n         */\n\n    }, {\n        key: \"linkify\",\n        value: function linkify(txt) {\n            return new Anser().linkify(txt);\n        }\n\n        /**\n         * Anser.ansiToHtml\n         * This replaces ANSI terminal escape codes with SPAN tags that wrap the\n         * content.\n         *\n         * This function only interprets ANSI SGR (Select Graphic Rendition) codes\n         * that can be represented in HTML.\n         * For example, cursor movement codes are ignored and hidden from output.\n         * The default style uses colors that are very close to the prescribed\n         * standard. The standard assumes that the text will have a black\n         * background. These colors are set as inline styles on the SPAN tags.\n         *\n         * Another option is to set `use_classes: true` in the options argument.\n         * This will instead set classes on the spans so the colors can be set via\n         * CSS. The class names used are of the format `ansi-*-fg/bg` and\n         * `ansi-bright-*-fg/bg` where `*` is the color name,\n         * i.e black/red/green/yellow/blue/magenta/cyan/white.\n         *\n         * @name Anser.ansiToHtml\n         * @function\n         * @param {String} txt The input text.\n         * @param {Object} options The options passed to the ansiToHTML method.\n         * @returns {String} The HTML output.\n         */\n\n    }, {\n        key: \"ansiToHtml\",\n        value: function ansiToHtml(txt, options) {\n            return new Anser().ansiToHtml(txt, options);\n        }\n\n        /**\n         * Anser.ansiToJson\n         * Converts ANSI input into JSON output.\n         *\n         * @name Anser.ansiToJson\n         * @function\n         * @param {String} txt The input text.\n         * @param {Object} options The options passed to the ansiToHTML method.\n         * @returns {String} The HTML output.\n         */\n\n    }, {\n        key: \"ansiToJson\",\n        value: function ansiToJson(txt, options) {\n            return new Anser().ansiToJson(txt, options);\n        }\n\n        /**\n         * Anser.ansiToText\n         * Converts ANSI input into text output.\n         *\n         * @name Anser.ansiToText\n         * @function\n         * @param {String} txt The input text.\n         * @returns {String} The text output.\n         */\n\n    }, {\n        key: \"ansiToText\",\n        value: function ansiToText(txt) {\n            return new Anser().ansiToText(txt);\n        }\n\n        /**\n         * Anser\n         * The `Anser` class.\n         *\n         * @name Anser\n         * @function\n         * @returns {Anser}\n         */\n\n    }]);\n\n    function Anser() {\n        _classCallCheck(this, Anser);\n\n        this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null;\n        this.bright = 0;\n        this.decorations = [];\n    }\n\n    /**\n     * setupPalette\n     * Sets up the palette.\n     *\n     * @name setupPalette\n     * @function\n     */\n\n\n    _createClass(Anser, [{\n        key: \"setupPalette\",\n        value: function setupPalette() {\n            this.PALETTE_COLORS = [];\n\n            // Index 0..15 : System color\n            for (var i = 0; i < 2; ++i) {\n                for (var j = 0; j < 8; ++j) {\n                    this.PALETTE_COLORS.push(ANSI_COLORS[i][j].color);\n                }\n            }\n\n            // Index 16..231 : RGB 6x6x6\n            // https://gist.github.com/jasonm23/2868981#file-xterm-256color-yaml\n            var levels = [0, 95, 135, 175, 215, 255];\n            var format = function format(r, g, b) {\n                return levels[r] + \", \" + levels[g] + \", \" + levels[b];\n            };\n            var r = void 0,\n                g = void 0,\n                b = void 0;\n            for (var _r = 0; _r < 6; ++_r) {\n                for (var _g = 0; _g < 6; ++_g) {\n                    for (var _b = 0; _b < 6; ++_b) {\n                        this.PALETTE_COLORS.push(format(_r, _g, _b));\n                    }\n                }\n            }\n\n            // Index 232..255 : Grayscale\n            var level = 8;\n            for (var _i = 0; _i < 24; ++_i, level += 10) {\n                this.PALETTE_COLORS.push(format(level, level, level));\n            }\n        }\n\n        /**\n         * escapeForHtml\n         * Escapes the input text.\n         *\n         * @name escapeForHtml\n         * @function\n         * @param {String} txt The input text.\n         * @returns {String} The escpaed HTML output.\n         */\n\n    }, {\n        key: \"escapeForHtml\",\n        value: function escapeForHtml(txt) {\n            return txt.replace(/[&<>\\\"]/gm, function (str) {\n                return str == \"&\" ? \"&amp;\" : str == '\"' ? \"&quot;\" : str == \"<\" ? \"&lt;\" : str == \">\" ? \"&gt;\" : \"\";\n            });\n        }\n\n        /**\n         * linkify\n         * Adds HTML link elements.\n         *\n         * @name linkify\n         * @function\n         * @param {String} txt The input text.\n         * @returns {String} The HTML output containing link elements.\n         */\n\n    }, {\n        key: \"linkify\",\n        value: function linkify(txt) {\n            return txt.replace(/(https?:\\/\\/[^\\s]+)/gm, function (str) {\n                return \"<a href=\\\"\" + str + \"\\\">\" + str + \"</a>\";\n            });\n        }\n\n        /**\n         * ansiToHtml\n         * Converts ANSI input into HTML output.\n         *\n         * @name ansiToHtml\n         * @function\n         * @param {String} txt The input text.\n         * @param {Object} options The options passed ot the `process` method.\n         * @returns {String} The HTML output.\n         */\n\n    }, {\n        key: \"ansiToHtml\",\n        value: function ansiToHtml(txt, options) {\n            return this.process(txt, options, true);\n        }\n\n        /**\n         * ansiToJson\n         * Converts ANSI input into HTML output.\n         *\n         * @name ansiToJson\n         * @function\n         * @param {String} txt The input text.\n         * @param {Object} options The options passed ot the `process` method.\n         * @returns {String} The JSON output.\n         */\n\n    }, {\n        key: \"ansiToJson\",\n        value: function ansiToJson(txt, options) {\n            options = options || {};\n            options.json = true;\n            options.clearLine = false;\n            return this.process(txt, options, true);\n        }\n\n        /**\n         * ansiToText\n         * Converts ANSI input into HTML output.\n         *\n         * @name ansiToText\n         * @function\n         * @param {String} txt The input text.\n         * @returns {String} The text output.\n         */\n\n    }, {\n        key: \"ansiToText\",\n        value: function ansiToText(txt) {\n            return this.process(txt, {}, false);\n        }\n\n        /**\n         * process\n         * Processes the input.\n         *\n         * @name process\n         * @function\n         * @param {String} txt The input text.\n         * @param {Object} options An object passed to `processChunk` method, extended with:\n         *\n         *  - `json` (Boolean): If `true`, the result will be an object.\n         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.\n         *\n         * @param {Boolean} markup\n         */\n\n    }, {\n        key: \"process\",\n        value: function process(txt, options, markup) {\n            var _this = this;\n\n            var self = this;\n            var raw_text_chunks = txt.split(/\\033\\[/);\n            var first_chunk = raw_text_chunks.shift(); // the first chunk is not the result of the split\n\n            if (options === undefined || options === null) {\n                options = {};\n            }\n            options.clearLine = /\\r/.test(txt); // check for Carriage Return\n            var color_chunks = raw_text_chunks.map(function (chunk) {\n                return _this.processChunk(chunk, options, markup);\n            });\n\n            if (options && options.json) {\n                var first = self.processChunkJson(\"\");\n                first.content = first_chunk;\n                first.clearLine = options.clearLine;\n                color_chunks.unshift(first);\n                if (options.remove_empty) {\n                    color_chunks = color_chunks.filter(function (c) {\n                        return !c.isEmpty();\n                    });\n                }\n                return color_chunks;\n            } else {\n                color_chunks.unshift(first_chunk);\n            }\n\n            return color_chunks.join(\"\");\n        }\n\n        /**\n         * processChunkJson\n         * Processes the current chunk into json output.\n         *\n         * @name processChunkJson\n         * @function\n         * @param {String} text The input text.\n         * @param {Object} options An object containing the following fields:\n         *\n         *  - `json` (Boolean): If `true`, the result will be an object.\n         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.\n         *\n         * @param {Boolean} markup If false, the colors will not be parsed.\n         * @return {Object} The result object:\n         *\n         *  - `content` (String): The text.\n         *  - `fg` (String|null): The foreground color.\n         *  - `bg` (String|null): The background color.\n         *  - `fg_truecolor` (String|null): The foreground true color (if 16m color is enabled).\n         *  - `bg_truecolor` (String|null): The background true color (if 16m color is enabled).\n         *  - `clearLine` (Boolean): `true` if a carriageReturn \\r was fount at end of line.\n         *  - `was_processed` (Bolean): `true` if the colors were processed, `false` otherwise.\n         *  - `isEmpty` (Function): A function returning `true` if the content is empty, or `false` otherwise.\n         *\n         */\n\n    }, {\n        key: \"processChunkJson\",\n        value: function processChunkJson(text, options, markup) {\n\n            // Are we using classes or styles?\n            options = typeof options == \"undefined\" ? {} : options;\n            var use_classes = options.use_classes = typeof options.use_classes != \"undefined\" && options.use_classes;\n            var key = options.key = use_classes ? \"class\" : \"color\";\n\n            var result = {\n                content: text,\n                fg: null,\n                bg: null,\n                fg_truecolor: null,\n                bg_truecolor: null,\n                isInverted: false,\n                clearLine: options.clearLine,\n                decoration: null,\n                decorations: [],\n                was_processed: false,\n                isEmpty: function isEmpty() {\n                    return !result.content;\n                }\n            };\n\n            // Each \"chunk\" is the text after the CSI (ESC + \"[\") and before the next CSI/EOF.\n            //\n            // This regex matches four groups within a chunk.\n            //\n            // The first and third groups match code type.\n            // We supported only SGR command. It has empty first group and \"m\" in third.\n            //\n            // The second group matches all of the number+semicolon command sequences\n            // before the \"m\" (or other trailing) character.\n            // These are the graphics or SGR commands.\n            //\n            // The last group is the text (including newlines) that is colored by\n            // the other group\"s commands.\n            var matches = text.match(/^([!\\x3c-\\x3f]*)([\\d;]*)([\\x20-\\x2c]*[\\x40-\\x7e])([\\s\\S]*)/m);\n\n            if (!matches) return result;\n\n            var orig_txt = result.content = matches[4];\n            var nums = matches[2].split(\";\");\n\n            // We currently support only \"SGR\" (Select Graphic Rendition)\n            // Simply ignore if not a SGR command.\n            if (matches[1] !== \"\" || matches[3] !== \"m\") {\n                return result;\n            }\n\n            if (!markup) {\n                return result;\n            }\n\n            var self = this;\n\n            while (nums.length > 0) {\n                var num_str = nums.shift();\n                var num = parseInt(num_str);\n\n                if (isNaN(num) || num === 0) {\n                    self.fg = self.bg = null;\n                    self.decorations = [];\n                } else if (num === 1) {\n                    self.decorations.push(\"bold\");\n                } else if (num === 2) {\n                    self.decorations.push(\"dim\");\n                    // Enable code 2 to get string\n                } else if (num === 3) {\n                    self.decorations.push(\"italic\");\n                } else if (num === 4) {\n                    self.decorations.push(\"underline\");\n                } else if (num === 5) {\n                    self.decorations.push(\"blink\");\n                } else if (num === 7) {\n                    self.decorations.push(\"reverse\");\n                } else if (num === 8) {\n                    self.decorations.push(\"hidden\");\n                    // Enable code 9 to get strikethrough\n                } else if (num === 9) {\n                    self.decorations.push(\"strikethrough\");\n                    /**\n                     * Add several widely used style codes\n                     * @see https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_(Select_Graphic_Rendition)_parameters\n                     */\n                } else if (num === 21) {\n                    self.removeDecoration(\"bold\");\n                } else if (num === 22) {\n                    self.removeDecoration(\"bold\");\n                    self.removeDecoration(\"dim\");\n                } else if (num === 23) {\n                    self.removeDecoration(\"italic\");\n                } else if (num === 24) {\n                    self.removeDecoration(\"underline\");\n                } else if (num === 25) {\n                    self.removeDecoration(\"blink\");\n                } else if (num === 27) {\n                    self.removeDecoration(\"reverse\");\n                } else if (num === 28) {\n                    self.removeDecoration(\"hidden\");\n                } else if (num === 29) {\n                    self.removeDecoration(\"strikethrough\");\n                } else if (num === 39) {\n                    self.fg = null;\n                } else if (num === 49) {\n                    self.bg = null;\n                    // Foreground color\n                } else if (num >= 30 && num < 38) {\n                    self.fg = ANSI_COLORS[0][num % 10][key];\n                    // Foreground bright color\n                } else if (num >= 90 && num < 98) {\n                    self.fg = ANSI_COLORS[1][num % 10][key];\n                    // Background color\n                } else if (num >= 40 && num < 48) {\n                    self.bg = ANSI_COLORS[0][num % 10][key];\n                    // Background bright color\n                } else if (num >= 100 && num < 108) {\n                    self.bg = ANSI_COLORS[1][num % 10][key];\n                } else if (num === 38 || num === 48) {\n                    // extend color (38=fg, 48=bg)\n                    var is_foreground = num === 38;\n                    if (nums.length >= 1) {\n                        var mode = nums.shift();\n                        if (mode === \"5\" && nums.length >= 1) {\n                            // palette color\n                            var palette_index = parseInt(nums.shift());\n                            if (palette_index >= 0 && palette_index <= 255) {\n                                if (!use_classes) {\n                                    if (!this.PALETTE_COLORS) {\n                                        self.setupPalette();\n                                    }\n                                    if (is_foreground) {\n                                        self.fg = this.PALETTE_COLORS[palette_index];\n                                    } else {\n                                        self.bg = this.PALETTE_COLORS[palette_index];\n                                    }\n                                } else {\n                                    var klass = palette_index >= 16 ? \"ansi-palette-\" + palette_index : ANSI_COLORS[palette_index > 7 ? 1 : 0][palette_index % 8][\"class\"];\n                                    if (is_foreground) {\n                                        self.fg = klass;\n                                    } else {\n                                        self.bg = klass;\n                                    }\n                                }\n                            }\n                        } else if (mode === \"2\" && nums.length >= 3) {\n                            // true color\n                            var r = parseInt(nums.shift());\n                            var g = parseInt(nums.shift());\n                            var b = parseInt(nums.shift());\n                            if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {\n                                var color = r + \", \" + g + \", \" + b;\n                                if (!use_classes) {\n                                    if (is_foreground) {\n                                        self.fg = color;\n                                    } else {\n                                        self.bg = color;\n                                    }\n                                } else {\n                                    if (is_foreground) {\n                                        self.fg = \"ansi-truecolor\";\n                                        self.fg_truecolor = color;\n                                    } else {\n                                        self.bg = \"ansi-truecolor\";\n                                        self.bg_truecolor = color;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (self.fg === null && self.bg === null && self.decorations.length === 0) {\n                return result;\n            } else {\n                var styles = [];\n                var classes = [];\n                var data = {};\n\n                result.fg = self.fg;\n                result.bg = self.bg;\n                result.fg_truecolor = self.fg_truecolor;\n                result.bg_truecolor = self.bg_truecolor;\n                result.decorations = self.decorations;\n                result.decoration = self.decorations.slice(-1).pop() || null;\n                result.was_processed = true;\n\n                return result;\n            }\n        }\n\n        /**\n         * processChunk\n         * Processes the current chunk of text.\n         *\n         * @name processChunk\n         * @function\n         * @param {String} text The input text.\n         * @param {Object} options An object containing the following fields:\n         *\n         *  - `json` (Boolean): If `true`, the result will be an object.\n         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.\n         *\n         * @param {Boolean} markup If false, the colors will not be parsed.\n         * @return {Object|String} The result (object if `json` is wanted back or string otherwise).\n         */\n\n    }, {\n        key: \"processChunk\",\n        value: function processChunk(text, options, markup) {\n            var _this2 = this;\n\n            options = options || {};\n            var jsonChunk = this.processChunkJson(text, options, markup);\n            var use_classes = options.use_classes;\n\n            // \"reverse\" decoration reverses foreground and background colors\n            jsonChunk.decorations = jsonChunk.decorations.filter(function (decoration) {\n                if (decoration === \"reverse\") {\n                    // when reversing, missing colors are defaulted to black (bg) and white (fg)\n                    if (!jsonChunk.fg) {\n                        jsonChunk.fg = ANSI_COLORS[0][7][use_classes ? \"class\" : \"color\"];\n                    }\n                    if (!jsonChunk.bg) {\n                        jsonChunk.bg = ANSI_COLORS[0][0][use_classes ? \"class\" : \"color\"];\n                    }\n                    var tmpFg = jsonChunk.fg;\n                    jsonChunk.fg = jsonChunk.bg;\n                    jsonChunk.bg = tmpFg;\n                    var tmpFgTrue = jsonChunk.fg_truecolor;\n                    jsonChunk.fg_truecolor = jsonChunk.bg_truecolor;\n                    jsonChunk.bg_truecolor = tmpFgTrue;\n                    jsonChunk.isInverted = true;\n                    return false;\n                }\n                return true;\n            });\n\n            if (options.json) {\n                return jsonChunk;\n            }\n            if (jsonChunk.isEmpty()) {\n                return \"\";\n            }\n            if (!jsonChunk.was_processed) {\n                return jsonChunk.content;\n            }\n\n            var colors = [];\n            var decorations = [];\n            var textDecorations = [];\n            var data = {};\n\n            var render_data = function render_data(data) {\n                var fragments = [];\n                var key = void 0;\n                for (key in data) {\n                    if (data.hasOwnProperty(key)) {\n                        fragments.push(\"data-\" + key + \"=\\\"\" + _this2.escapeForHtml(data[key]) + \"\\\"\");\n                    }\n                }\n                return fragments.length > 0 ? \" \" + fragments.join(\" \") : \"\";\n            };\n\n            if (jsonChunk.isInverted) {\n                data[\"ansi-is-inverted\"] = \"true\";\n            }\n\n            if (jsonChunk.fg) {\n                if (use_classes) {\n                    colors.push(jsonChunk.fg + \"-fg\");\n                    if (jsonChunk.fg_truecolor !== null) {\n                        data[\"ansi-truecolor-fg\"] = jsonChunk.fg_truecolor;\n                        jsonChunk.fg_truecolor = null;\n                    }\n                } else {\n                    colors.push(\"color:rgb(\" + jsonChunk.fg + \")\");\n                }\n            }\n\n            if (jsonChunk.bg) {\n                if (use_classes) {\n                    colors.push(jsonChunk.bg + \"-bg\");\n                    if (jsonChunk.bg_truecolor !== null) {\n                        data[\"ansi-truecolor-bg\"] = jsonChunk.bg_truecolor;\n                        jsonChunk.bg_truecolor = null;\n                    }\n                } else {\n                    colors.push(\"background-color:rgb(\" + jsonChunk.bg + \")\");\n                }\n            }\n\n            jsonChunk.decorations.forEach(function (decoration) {\n                // use classes\n                if (use_classes) {\n                    decorations.push(\"ansi-\" + decoration);\n                    return;\n                }\n                // use styles\n                if (decoration === \"bold\") {\n                    decorations.push(\"font-weight:bold\");\n                } else if (decoration === \"dim\") {\n                    decorations.push(\"opacity:0.5\");\n                } else if (decoration === \"italic\") {\n                    decorations.push(\"font-style:italic\");\n                } else if (decoration === \"hidden\") {\n                    decorations.push(\"visibility:hidden\");\n                } else if (decoration === \"strikethrough\") {\n                    textDecorations.push(\"line-through\");\n                } else {\n                    // underline and blink are treated here\n                    textDecorations.push(decoration);\n                }\n            });\n\n            if (textDecorations.length) {\n                decorations.push(\"text-decoration:\" + textDecorations.join(\" \"));\n            }\n\n            if (use_classes) {\n                return \"<span class=\\\"\" + colors.concat(decorations).join(\" \") + \"\\\"\" + render_data(data) + \">\" + jsonChunk.content + \"</span>\";\n            } else {\n                return \"<span style=\\\"\" + colors.concat(decorations).join(\";\") + \"\\\"\" + render_data(data) + \">\" + jsonChunk.content + \"</span>\";\n            }\n        }\n    }, {\n        key: \"removeDecoration\",\n        value: function removeDecoration(decoration) {\n            var index = this.decorations.indexOf(decoration);\n\n            if (index >= 0) {\n                this.decorations.splice(index, 1);\n            }\n        }\n    }]);\n\n    return Anser;\n}();\n\nmodule.exports = Anser;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYW5zZXIvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBLGlDQUFpQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwrREFBK0QseURBQXlELHFFQUFxRSw2REFBNkQsd0JBQXdCOztBQUVqakIsa0RBQWtELDBDQUEwQzs7QUFFNUYsc0JBQXNCLHlDQUF5QyxJQUFJLHlDQUF5QyxJQUFJLDJDQUEyQyxJQUFJLDhDQUE4QyxJQUFJLDBDQUEwQyxJQUFJLCtDQUErQyxJQUFJLDRDQUE0QyxJQUFJLDZDQUE2QyxNQUFNLG1EQUFtRCxJQUFJLGtEQUFrRCxJQUFJLGtEQUFrRCxJQUFJLHNEQUFzRCxJQUFJLG1EQUFtRCxJQUFJLHVEQUF1RCxJQUFJLG9EQUFvRCxJQUFJLHNEQUFzRDs7QUFFbDFCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IscUJBQXFCLFFBQVE7QUFDN0I7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixxQkFBcUIsUUFBUTtBQUM3Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IscUJBQXFCLFFBQVE7QUFDN0I7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLHFCQUFxQixRQUFRO0FBQzdCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQyxpQ0FBaUMsUUFBUTtBQUN6QyxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLHFCQUFxQixRQUFRO0FBQzdCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0JBQXdCLHNCQUFzQixzQkFBc0I7QUFDOUcsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLHFCQUFxQixRQUFRO0FBQzdCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixxQkFBcUIsUUFBUTtBQUM3Qjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IscUJBQXFCLFFBQVE7QUFDN0I7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLHFCQUFxQixRQUFRO0FBQzdCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7O0FBRTNEOztBQUVBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsb0JBQW9CLGVBQWU7QUFDbkM7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fuc2VyL2xpYi9pbmRleC5qcz9hYTQxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vLyBUaGlzIGZpbGUgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBieSBAZHJ1ZHJ1IChodHRwczovL2dpdGh1Yi5jb20vZHJ1ZHJ1L2Fuc2lfdXApLCBNSVQsIDIwMTFcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEFOU0lfQ09MT1JTID0gW1t7IGNvbG9yOiBcIjAsIDAsIDBcIiwgXCJjbGFzc1wiOiBcImFuc2ktYmxhY2tcIiB9LCB7IGNvbG9yOiBcIjE4NywgMCwgMFwiLCBcImNsYXNzXCI6IFwiYW5zaS1yZWRcIiB9LCB7IGNvbG9yOiBcIjAsIDE4NywgMFwiLCBcImNsYXNzXCI6IFwiYW5zaS1ncmVlblwiIH0sIHsgY29sb3I6IFwiMTg3LCAxODcsIDBcIiwgXCJjbGFzc1wiOiBcImFuc2kteWVsbG93XCIgfSwgeyBjb2xvcjogXCIwLCAwLCAxODdcIiwgXCJjbGFzc1wiOiBcImFuc2ktYmx1ZVwiIH0sIHsgY29sb3I6IFwiMTg3LCAwLCAxODdcIiwgXCJjbGFzc1wiOiBcImFuc2ktbWFnZW50YVwiIH0sIHsgY29sb3I6IFwiMCwgMTg3LCAxODdcIiwgXCJjbGFzc1wiOiBcImFuc2ktY3lhblwiIH0sIHsgY29sb3I6IFwiMjU1LDI1NSwyNTVcIiwgXCJjbGFzc1wiOiBcImFuc2ktd2hpdGVcIiB9XSwgW3sgY29sb3I6IFwiODUsIDg1LCA4NVwiLCBcImNsYXNzXCI6IFwiYW5zaS1icmlnaHQtYmxhY2tcIiB9LCB7IGNvbG9yOiBcIjI1NSwgODUsIDg1XCIsIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC1yZWRcIiB9LCB7IGNvbG9yOiBcIjAsIDI1NSwgMFwiLCBcImNsYXNzXCI6IFwiYW5zaS1icmlnaHQtZ3JlZW5cIiB9LCB7IGNvbG9yOiBcIjI1NSwgMjU1LCA4NVwiLCBcImNsYXNzXCI6IFwiYW5zaS1icmlnaHQteWVsbG93XCIgfSwgeyBjb2xvcjogXCI4NSwgODUsIDI1NVwiLCBcImNsYXNzXCI6IFwiYW5zaS1icmlnaHQtYmx1ZVwiIH0sIHsgY29sb3I6IFwiMjU1LCA4NSwgMjU1XCIsIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC1tYWdlbnRhXCIgfSwgeyBjb2xvcjogXCI4NSwgMjU1LCAyNTVcIiwgXCJjbGFzc1wiOiBcImFuc2ktYnJpZ2h0LWN5YW5cIiB9LCB7IGNvbG9yOiBcIjI1NSwgMjU1LCAyNTVcIiwgXCJjbGFzc1wiOiBcImFuc2ktYnJpZ2h0LXdoaXRlXCIgfV1dO1xuXG52YXIgQW5zZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgX2NyZWF0ZUNsYXNzKEFuc2VyLCBudWxsLCBbe1xuICAgICAgICBrZXk6IFwiZXNjYXBlRm9ySHRtbFwiLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuc2VyLmVzY2FwZUZvckh0bWxcbiAgICAgICAgICogRXNjYXBlIHRoZSBpbnB1dCBIVE1MLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGRvZXMgdGhlIG1pbmltdW0gZXNjYXBpbmcgb2YgdGV4dCB0byBtYWtlIGl0IGNvbXBsaWFudCB3aXRoIEhUTUwuXG4gICAgICAgICAqIEluIHBhcnRpY3VsYXIsIHRoZSAnJicsJzwnLCBhbmQgJz4nIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRoaXMgc2hvdWxkXG4gICAgICAgICAqIGJlIHJ1biBwcmlvciB0byBgYW5zaVRvSHRtbGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lIEFuc2VyLmVzY2FwZUZvckh0bWxcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQgKGNvbnRhaW5pbmcgdGhlIEFOU0kgc25pcHBldHMpLlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgZXNjYXBlZCBodG1sLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVzY2FwZUZvckh0bWwodHh0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFuc2VyKCkuZXNjYXBlRm9ySHRtbCh0eHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuc2VyLmxpbmtpZnlcbiAgICAgICAgICogQWRkcyB0aGUgbGlua3MgaW4gdGhlIEhUTUwuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgcmVwbGFjZXMgYW55IGxpbmtzIGluIHRoZSB0ZXh0IHdpdGggYW5jaG9yIHRhZ3MgdGhhdCBkaXNwbGF5IHRoZVxuICAgICAgICAgKiBsaW5rLiBUaGUgbGlua3Mgc2hvdWxkIGhhdmUgYXQgbGVhc3Qgb25lIHdoaXRlc3BhY2UgY2hhcmFjdGVyXG4gICAgICAgICAqIHN1cnJvdW5kaW5nIGl0LiBBbHNvLCB5b3Ugc2hvdWxkIGFwcGx5IHRoaXMgYWZ0ZXIgeW91IGhhdmUgcnVuXG4gICAgICAgICAqIGBhbnNpVG9IdG1sYCBvbiB0aGUgdGV4dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgQW5zZXIubGlua2lmeVxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dC5cbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIEhUTUwgY29udGFpbmluZyB0aGUgPGE+IHRhZ3MgKHVuZXNjYXBlZCkuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwibGlua2lmeVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGlua2lmeSh0eHQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW5zZXIoKS5saW5raWZ5KHR4dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQW5zZXIuYW5zaVRvSHRtbFxuICAgICAgICAgKiBUaGlzIHJlcGxhY2VzIEFOU0kgdGVybWluYWwgZXNjYXBlIGNvZGVzIHdpdGggU1BBTiB0YWdzIHRoYXQgd3JhcCB0aGVcbiAgICAgICAgICogY29udGVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBvbmx5IGludGVycHJldHMgQU5TSSBTR1IgKFNlbGVjdCBHcmFwaGljIFJlbmRpdGlvbikgY29kZXNcbiAgICAgICAgICogdGhhdCBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gSFRNTC5cbiAgICAgICAgICogRm9yIGV4YW1wbGUsIGN1cnNvciBtb3ZlbWVudCBjb2RlcyBhcmUgaWdub3JlZCBhbmQgaGlkZGVuIGZyb20gb3V0cHV0LlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBzdHlsZSB1c2VzIGNvbG9ycyB0aGF0IGFyZSB2ZXJ5IGNsb3NlIHRvIHRoZSBwcmVzY3JpYmVkXG4gICAgICAgICAqIHN0YW5kYXJkLiBUaGUgc3RhbmRhcmQgYXNzdW1lcyB0aGF0IHRoZSB0ZXh0IHdpbGwgaGF2ZSBhIGJsYWNrXG4gICAgICAgICAqIGJhY2tncm91bmQuIFRoZXNlIGNvbG9ycyBhcmUgc2V0IGFzIGlubGluZSBzdHlsZXMgb24gdGhlIFNQQU4gdGFncy5cbiAgICAgICAgICpcbiAgICAgICAgICogQW5vdGhlciBvcHRpb24gaXMgdG8gc2V0IGB1c2VfY2xhc3NlczogdHJ1ZWAgaW4gdGhlIG9wdGlvbnMgYXJndW1lbnQuXG4gICAgICAgICAqIFRoaXMgd2lsbCBpbnN0ZWFkIHNldCBjbGFzc2VzIG9uIHRoZSBzcGFucyBzbyB0aGUgY29sb3JzIGNhbiBiZSBzZXQgdmlhXG4gICAgICAgICAqIENTUy4gVGhlIGNsYXNzIG5hbWVzIHVzZWQgYXJlIG9mIHRoZSBmb3JtYXQgYGFuc2ktKi1mZy9iZ2AgYW5kXG4gICAgICAgICAqIGBhbnNpLWJyaWdodC0qLWZnL2JnYCB3aGVyZSBgKmAgaXMgdGhlIGNvbG9yIG5hbWUsXG4gICAgICAgICAqIGkuZSBibGFjay9yZWQvZ3JlZW4veWVsbG93L2JsdWUvbWFnZW50YS9jeWFuL3doaXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBBbnNlci5hbnNpVG9IdG1sXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIGFuc2lUb0hUTUwgbWV0aG9kLlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSFRNTCBvdXRwdXQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYW5zaVRvSHRtbFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5zaVRvSHRtbCh0eHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW5zZXIoKS5hbnNpVG9IdG1sKHR4dCwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQW5zZXIuYW5zaVRvSnNvblxuICAgICAgICAgKiBDb252ZXJ0cyBBTlNJIGlucHV0IGludG8gSlNPTiBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lIEFuc2VyLmFuc2lUb0pzb25cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgYW5zaVRvSFRNTCBtZXRob2QuXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBIVE1MIG91dHB1dC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhbnNpVG9Kc29uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbnNpVG9Kc29uKHR4dCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbnNlcigpLmFuc2lUb0pzb24odHh0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbnNlci5hbnNpVG9UZXh0XG4gICAgICAgICAqIENvbnZlcnRzIEFOU0kgaW5wdXQgaW50byB0ZXh0IG91dHB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgQW5zZXIuYW5zaVRvVGV4dFxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dC5cbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHRleHQgb3V0cHV0LlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImFuc2lUb1RleHRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuc2lUb1RleHQodHh0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFuc2VyKCkuYW5zaVRvVGV4dCh0eHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuc2VyXG4gICAgICAgICAqIFRoZSBgQW5zZXJgIGNsYXNzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBBbnNlclxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHJldHVybnMge0Fuc2VyfVxuICAgICAgICAgKi9cblxuICAgIH1dKTtcblxuICAgIGZ1bmN0aW9uIEFuc2VyKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQW5zZXIpO1xuXG4gICAgICAgIHRoaXMuZmcgPSB0aGlzLmJnID0gdGhpcy5mZ190cnVlY29sb3IgPSB0aGlzLmJnX3RydWVjb2xvciA9IG51bGw7XG4gICAgICAgIHRoaXMuYnJpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldHVwUGFsZXR0ZVxuICAgICAqIFNldHMgdXAgdGhlIHBhbGV0dGUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBzZXR1cFBhbGV0dGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEFuc2VyLCBbe1xuICAgICAgICBrZXk6IFwic2V0dXBQYWxldHRlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cFBhbGV0dGUoKSB7XG4gICAgICAgICAgICB0aGlzLlBBTEVUVEVfQ09MT1JTID0gW107XG5cbiAgICAgICAgICAgIC8vIEluZGV4IDAuLjE1IDogU3lzdGVtIGNvbG9yXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuUEFMRVRURV9DT0xPUlMucHVzaChBTlNJX0NPTE9SU1tpXVtqXS5jb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbmRleCAxNi4uMjMxIDogUkdCIDZ4Nng2XG4gICAgICAgICAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qYXNvbm0yMy8yODY4OTgxI2ZpbGUteHRlcm0tMjU2Y29sb3IteWFtbFxuICAgICAgICAgICAgdmFyIGxldmVscyA9IFswLCA5NSwgMTM1LCAxNzUsIDIxNSwgMjU1XTtcbiAgICAgICAgICAgIHZhciBmb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQociwgZywgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZXZlbHNbcl0gKyBcIiwgXCIgKyBsZXZlbHNbZ10gKyBcIiwgXCIgKyBsZXZlbHNbYl07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHIgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZyA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBiID0gdm9pZCAwO1xuICAgICAgICAgICAgZm9yICh2YXIgX3IgPSAwOyBfciA8IDY7ICsrX3IpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZyA9IDA7IF9nIDwgNjsgKytfZykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IDA7IF9iIDwgNjsgKytfYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5QQUxFVFRFX0NPTE9SUy5wdXNoKGZvcm1hdChfciwgX2csIF9iKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluZGV4IDIzMi4uMjU1IDogR3JheXNjYWxlXG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSA4O1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IDI0OyArK19pLCBsZXZlbCArPSAxMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuUEFMRVRURV9DT0xPUlMucHVzaChmb3JtYXQobGV2ZWwsIGxldmVsLCBsZXZlbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGVzY2FwZUZvckh0bWxcbiAgICAgICAgICogRXNjYXBlcyB0aGUgaW5wdXQgdGV4dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgZXNjYXBlRm9ySHRtbFxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dC5cbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGVzY3BhZWQgSFRNTCBvdXRwdXQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZXNjYXBlRm9ySHRtbFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXNjYXBlRm9ySHRtbCh0eHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0eHQucmVwbGFjZSgvWyY8PlxcXCJdL2dtLCBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0ciA9PSBcIiZcIiA/IFwiJmFtcDtcIiA6IHN0ciA9PSAnXCInID8gXCImcXVvdDtcIiA6IHN0ciA9PSBcIjxcIiA/IFwiJmx0O1wiIDogc3RyID09IFwiPlwiID8gXCImZ3Q7XCIgOiBcIlwiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogbGlua2lmeVxuICAgICAgICAgKiBBZGRzIEhUTUwgbGluayBlbGVtZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgbGlua2lmeVxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dC5cbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIEhUTUwgb3V0cHV0IGNvbnRhaW5pbmcgbGluayBlbGVtZW50cy5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJsaW5raWZ5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5raWZ5KHR4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHR4dC5yZXBsYWNlKC8oaHR0cHM/OlxcL1xcL1teXFxzXSspL2dtLCBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiPGEgaHJlZj1cXFwiXCIgKyBzdHIgKyBcIlxcXCI+XCIgKyBzdHIgKyBcIjwvYT5cIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFuc2lUb0h0bWxcbiAgICAgICAgICogQ29udmVydHMgQU5TSSBpbnB1dCBpbnRvIEhUTUwgb3V0cHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBhbnNpVG9IdG1sXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBwYXNzZWQgb3QgdGhlIGBwcm9jZXNzYCBtZXRob2QuXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBIVE1MIG91dHB1dC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhbnNpVG9IdG1sXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbnNpVG9IdG1sKHR4dCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzcyh0eHQsIG9wdGlvbnMsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFuc2lUb0pzb25cbiAgICAgICAgICogQ29udmVydHMgQU5TSSBpbnB1dCBpbnRvIEhUTUwgb3V0cHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBhbnNpVG9Kc29uXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBwYXNzZWQgb3QgdGhlIGBwcm9jZXNzYCBtZXRob2QuXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBKU09OIG91dHB1dC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhbnNpVG9Kc29uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbnNpVG9Kc29uKHR4dCwgb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICBvcHRpb25zLmpzb24gPSB0cnVlO1xuICAgICAgICAgICAgb3B0aW9ucy5jbGVhckxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3ModHh0LCBvcHRpb25zLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhbnNpVG9UZXh0XG4gICAgICAgICAqIENvbnZlcnRzIEFOU0kgaW5wdXQgaW50byBIVE1MIG91dHB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgYW5zaVRvVGV4dFxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dC5cbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHRleHQgb3V0cHV0LlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImFuc2lUb1RleHRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuc2lUb1RleHQodHh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzKHR4dCwge30sIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcm9jZXNzXG4gICAgICAgICAqIFByb2Nlc3NlcyB0aGUgaW5wdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lIHByb2Nlc3NcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCBwYXNzZWQgdG8gYHByb2Nlc3NDaHVua2AgbWV0aG9kLCBleHRlbmRlZCB3aXRoOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgLSBganNvbmAgKEJvb2xlYW4pOiBJZiBgdHJ1ZWAsIHRoZSByZXN1bHQgd2lsbCBiZSBhbiBvYmplY3QuXG4gICAgICAgICAqICAtIGB1c2VfY2xhc3Nlc2AgKEJvb2xlYW4pOiBJZiBgdHJ1ZWAsIEhUTUwgY2xhc3NlcyB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBIVE1MIG91dHB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBtYXJrdXBcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJwcm9jZXNzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzKHR4dCwgb3B0aW9ucywgbWFya3VwKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgcmF3X3RleHRfY2h1bmtzID0gdHh0LnNwbGl0KC9cXDAzM1xcWy8pO1xuICAgICAgICAgICAgdmFyIGZpcnN0X2NodW5rID0gcmF3X3RleHRfY2h1bmtzLnNoaWZ0KCk7IC8vIHRoZSBmaXJzdCBjaHVuayBpcyBub3QgdGhlIHJlc3VsdCBvZiB0aGUgc3BsaXRcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5jbGVhckxpbmUgPSAvXFxyLy50ZXN0KHR4dCk7IC8vIGNoZWNrIGZvciBDYXJyaWFnZSBSZXR1cm5cbiAgICAgICAgICAgIHZhciBjb2xvcl9jaHVua3MgPSByYXdfdGV4dF9jaHVua3MubWFwKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9jZXNzQ2h1bmsoY2h1bmssIG9wdGlvbnMsIG1hcmt1cCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5qc29uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gc2VsZi5wcm9jZXNzQ2h1bmtKc29uKFwiXCIpO1xuICAgICAgICAgICAgICAgIGZpcnN0LmNvbnRlbnQgPSBmaXJzdF9jaHVuaztcbiAgICAgICAgICAgICAgICBmaXJzdC5jbGVhckxpbmUgPSBvcHRpb25zLmNsZWFyTGluZTtcbiAgICAgICAgICAgICAgICBjb2xvcl9jaHVua3MudW5zaGlmdChmaXJzdCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVtb3ZlX2VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yX2NodW5rcyA9IGNvbG9yX2NodW5rcy5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhYy5pc0VtcHR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3JfY2h1bmtzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2xvcl9jaHVua3MudW5zaGlmdChmaXJzdF9jaHVuayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb2xvcl9jaHVua3Muam9pbihcIlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcm9jZXNzQ2h1bmtKc29uXG4gICAgICAgICAqIFByb2Nlc3NlcyB0aGUgY3VycmVudCBjaHVuayBpbnRvIGpzb24gb3V0cHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBwcm9jZXNzQ2h1bmtKc29uXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgaW5wdXQgdGV4dC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBmaWVsZHM6XG4gICAgICAgICAqXG4gICAgICAgICAqICAtIGBqc29uYCAoQm9vbGVhbik6IElmIGB0cnVlYCwgdGhlIHJlc3VsdCB3aWxsIGJlIGFuIG9iamVjdC5cbiAgICAgICAgICogIC0gYHVzZV9jbGFzc2VzYCAoQm9vbGVhbik6IElmIGB0cnVlYCwgSFRNTCBjbGFzc2VzIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIEhUTUwgb3V0cHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hcmt1cCBJZiBmYWxzZSwgdGhlIGNvbG9ycyB3aWxsIG5vdCBiZSBwYXJzZWQuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdCBvYmplY3Q6XG4gICAgICAgICAqXG4gICAgICAgICAqICAtIGBjb250ZW50YCAoU3RyaW5nKTogVGhlIHRleHQuXG4gICAgICAgICAqICAtIGBmZ2AgKFN0cmluZ3xudWxsKTogVGhlIGZvcmVncm91bmQgY29sb3IuXG4gICAgICAgICAqICAtIGBiZ2AgKFN0cmluZ3xudWxsKTogVGhlIGJhY2tncm91bmQgY29sb3IuXG4gICAgICAgICAqICAtIGBmZ190cnVlY29sb3JgIChTdHJpbmd8bnVsbCk6IFRoZSBmb3JlZ3JvdW5kIHRydWUgY29sb3IgKGlmIDE2bSBjb2xvciBpcyBlbmFibGVkKS5cbiAgICAgICAgICogIC0gYGJnX3RydWVjb2xvcmAgKFN0cmluZ3xudWxsKTogVGhlIGJhY2tncm91bmQgdHJ1ZSBjb2xvciAoaWYgMTZtIGNvbG9yIGlzIGVuYWJsZWQpLlxuICAgICAgICAgKiAgLSBgY2xlYXJMaW5lYCAoQm9vbGVhbik6IGB0cnVlYCBpZiBhIGNhcnJpYWdlUmV0dXJuIFxcciB3YXMgZm91bnQgYXQgZW5kIG9mIGxpbmUuXG4gICAgICAgICAqICAtIGB3YXNfcHJvY2Vzc2VkYCAoQm9sZWFuKTogYHRydWVgIGlmIHRoZSBjb2xvcnMgd2VyZSBwcm9jZXNzZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAgICAgKiAgLSBgaXNFbXB0eWAgKEZ1bmN0aW9uKTogQSBmdW5jdGlvbiByZXR1cm5pbmcgYHRydWVgIGlmIHRoZSBjb250ZW50IGlzIGVtcHR5LCBvciBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgICAgICpcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJwcm9jZXNzQ2h1bmtKc29uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzQ2h1bmtKc29uKHRleHQsIG9wdGlvbnMsIG1hcmt1cCkge1xuXG4gICAgICAgICAgICAvLyBBcmUgd2UgdXNpbmcgY2xhc3NlcyBvciBzdHlsZXM/XG4gICAgICAgICAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT0gXCJ1bmRlZmluZWRcIiA/IHt9IDogb3B0aW9ucztcbiAgICAgICAgICAgIHZhciB1c2VfY2xhc3NlcyA9IG9wdGlvbnMudXNlX2NsYXNzZXMgPSB0eXBlb2Ygb3B0aW9ucy51c2VfY2xhc3NlcyAhPSBcInVuZGVmaW5lZFwiICYmIG9wdGlvbnMudXNlX2NsYXNzZXM7XG4gICAgICAgICAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXkgPSB1c2VfY2xhc3NlcyA/IFwiY2xhc3NcIiA6IFwiY29sb3JcIjtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0ZXh0LFxuICAgICAgICAgICAgICAgIGZnOiBudWxsLFxuICAgICAgICAgICAgICAgIGJnOiBudWxsLFxuICAgICAgICAgICAgICAgIGZnX3RydWVjb2xvcjogbnVsbCxcbiAgICAgICAgICAgICAgICBiZ190cnVlY29sb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgaXNJbnZlcnRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2xlYXJMaW5lOiBvcHRpb25zLmNsZWFyTGluZSxcbiAgICAgICAgICAgICAgICBkZWNvcmF0aW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIGRlY29yYXRpb25zOiBbXSxcbiAgICAgICAgICAgICAgICB3YXNfcHJvY2Vzc2VkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXJlc3VsdC5jb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEVhY2ggXCJjaHVua1wiIGlzIHRoZSB0ZXh0IGFmdGVyIHRoZSBDU0kgKEVTQyArIFwiW1wiKSBhbmQgYmVmb3JlIHRoZSBuZXh0IENTSS9FT0YuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhpcyByZWdleCBtYXRjaGVzIGZvdXIgZ3JvdXBzIHdpdGhpbiBhIGNodW5rLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBhbmQgdGhpcmQgZ3JvdXBzIG1hdGNoIGNvZGUgdHlwZS5cbiAgICAgICAgICAgIC8vIFdlIHN1cHBvcnRlZCBvbmx5IFNHUiBjb21tYW5kLiBJdCBoYXMgZW1wdHkgZmlyc3QgZ3JvdXAgYW5kIFwibVwiIGluIHRoaXJkLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSBzZWNvbmQgZ3JvdXAgbWF0Y2hlcyBhbGwgb2YgdGhlIG51bWJlcitzZW1pY29sb24gY29tbWFuZCBzZXF1ZW5jZXNcbiAgICAgICAgICAgIC8vIGJlZm9yZSB0aGUgXCJtXCIgKG9yIG90aGVyIHRyYWlsaW5nKSBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIGdyYXBoaWNzIG9yIFNHUiBjb21tYW5kcy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgbGFzdCBncm91cCBpcyB0aGUgdGV4dCAoaW5jbHVkaW5nIG5ld2xpbmVzKSB0aGF0IGlzIGNvbG9yZWQgYnlcbiAgICAgICAgICAgIC8vIHRoZSBvdGhlciBncm91cFwicyBjb21tYW5kcy5cbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gdGV4dC5tYXRjaCgvXihbIVxceDNjLVxceDNmXSopKFtcXGQ7XSopKFtcXHgyMC1cXHgyY10qW1xceDQwLVxceDdlXSkoW1xcc1xcU10qKS9tKTtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaGVzKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgICAgICB2YXIgb3JpZ190eHQgPSByZXN1bHQuY29udGVudCA9IG1hdGNoZXNbNF07XG4gICAgICAgICAgICB2YXIgbnVtcyA9IG1hdGNoZXNbMl0uc3BsaXQoXCI7XCIpO1xuXG4gICAgICAgICAgICAvLyBXZSBjdXJyZW50bHkgc3VwcG9ydCBvbmx5IFwiU0dSXCIgKFNlbGVjdCBHcmFwaGljIFJlbmRpdGlvbilcbiAgICAgICAgICAgIC8vIFNpbXBseSBpZ25vcmUgaWYgbm90IGEgU0dSIGNvbW1hbmQuXG4gICAgICAgICAgICBpZiAobWF0Y2hlc1sxXSAhPT0gXCJcIiB8fCBtYXRjaGVzWzNdICE9PSBcIm1cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghbWFya3VwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICB3aGlsZSAobnVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIG51bV9zdHIgPSBudW1zLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdmFyIG51bSA9IHBhcnNlSW50KG51bV9zdHIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKG51bSkgfHwgbnVtID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmcgPSBzZWxmLmJnID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb3JhdGlvbnMucHVzaChcImJvbGRcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9ucy5wdXNoKFwiZGltXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBFbmFibGUgY29kZSAyIHRvIGdldCBzdHJpbmdcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29yYXRpb25zLnB1c2goXCJpdGFsaWNcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9ucy5wdXNoKFwidW5kZXJsaW5lXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb3JhdGlvbnMucHVzaChcImJsaW5rXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09PSA3KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb3JhdGlvbnMucHVzaChcInJldmVyc2VcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9ucy5wdXNoKFwiaGlkZGVuXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBFbmFibGUgY29kZSA5IHRvIGdldCBzdHJpa2V0aHJvdWdoXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9ucy5wdXNoKFwic3RyaWtldGhyb3VnaFwiKTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEFkZCBzZXZlcmFsIHdpZGVseSB1c2VkIHN0eWxlIGNvZGVzXG4gICAgICAgICAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNTR1JfKFNlbGVjdF9HcmFwaGljX1JlbmRpdGlvbilfcGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMjEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVEZWNvcmF0aW9uKFwiYm9sZFwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMjIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVEZWNvcmF0aW9uKFwiYm9sZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVEZWNvcmF0aW9uKFwiZGltXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09PSAyMykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZURlY29yYXRpb24oXCJpdGFsaWNcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT09IDI0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlRGVjb3JhdGlvbihcInVuZGVybGluZVwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMjUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVEZWNvcmF0aW9uKFwiYmxpbmtcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT09IDI3KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlRGVjb3JhdGlvbihcInJldmVyc2VcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT09IDI4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlRGVjb3JhdGlvbihcImhpZGRlblwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMjkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVEZWNvcmF0aW9uKFwic3RyaWtldGhyb3VnaFwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMzkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5mZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT09IDQ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3JlZ3JvdW5kIGNvbG9yXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPj0gMzAgJiYgbnVtIDwgMzgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5mZyA9IEFOU0lfQ09MT1JTWzBdW251bSAlIDEwXVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3JlZ3JvdW5kIGJyaWdodCBjb2xvclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID49IDkwICYmIG51bSA8IDk4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmcgPSBBTlNJX0NPTE9SU1sxXVtudW0gJSAxMF1ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmFja2dyb3VuZCBjb2xvclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID49IDQwICYmIG51bSA8IDQ4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYmcgPSBBTlNJX0NPTE9SU1swXVtudW0gJSAxMF1ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmFja2dyb3VuZCBicmlnaHQgY29sb3JcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA+PSAxMDAgJiYgbnVtIDwgMTA4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYmcgPSBBTlNJX0NPTE9SU1sxXVtudW0gJSAxMF1ba2V5XTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMzggfHwgbnVtID09PSA0OCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBleHRlbmQgY29sb3IgKDM4PWZnLCA0OD1iZylcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzX2ZvcmVncm91bmQgPSBudW0gPT09IDM4O1xuICAgICAgICAgICAgICAgICAgICBpZiAobnVtcy5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGUgPSBudW1zLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gXCI1XCIgJiYgbnVtcy5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhbGV0dGUgY29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFsZXR0ZV9pbmRleCA9IHBhcnNlSW50KG51bXMuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhbGV0dGVfaW5kZXggPj0gMCAmJiBwYWxldHRlX2luZGV4IDw9IDI1NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZV9jbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuUEFMRVRURV9DT0xPUlMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNldHVwUGFsZXR0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2ZvcmVncm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZnID0gdGhpcy5QQUxFVFRFX0NPTE9SU1twYWxldHRlX2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5iZyA9IHRoaXMuUEFMRVRURV9DT0xPUlNbcGFsZXR0ZV9pbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2xhc3MgPSBwYWxldHRlX2luZGV4ID49IDE2ID8gXCJhbnNpLXBhbGV0dGUtXCIgKyBwYWxldHRlX2luZGV4IDogQU5TSV9DT0xPUlNbcGFsZXR0ZV9pbmRleCA+IDcgPyAxIDogMF1bcGFsZXR0ZV9pbmRleCAlIDhdW1wiY2xhc3NcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZm9yZWdyb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmcgPSBrbGFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5iZyA9IGtsYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSBcIjJcIiAmJiBudW1zLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSBjb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gcGFyc2VJbnQobnVtcy5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IHBhcnNlSW50KG51bXMuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBwYXJzZUludChudW1zLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID49IDAgJiYgciA8PSAyNTUgJiYgZyA+PSAwICYmIGcgPD0gMjU1ICYmIGIgPj0gMCAmJiBiIDw9IDI1NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSByICsgXCIsIFwiICsgZyArIFwiLCBcIiArIGI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXNlX2NsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc19mb3JlZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mZyA9IGNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJnID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZm9yZWdyb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmcgPSBcImFuc2ktdHJ1ZWNvbG9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mZ190cnVlY29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5iZyA9IFwiYW5zaS10cnVlY29sb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJnX3RydWVjb2xvciA9IGNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZi5mZyA9PT0gbnVsbCAmJiBzZWxmLmJnID09PSBudWxsICYmIHNlbGYuZGVjb3JhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc2VzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcblxuICAgICAgICAgICAgICAgIHJlc3VsdC5mZyA9IHNlbGYuZmc7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmJnID0gc2VsZi5iZztcbiAgICAgICAgICAgICAgICByZXN1bHQuZmdfdHJ1ZWNvbG9yID0gc2VsZi5mZ190cnVlY29sb3I7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmJnX3RydWVjb2xvciA9IHNlbGYuYmdfdHJ1ZWNvbG9yO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kZWNvcmF0aW9ucyA9IHNlbGYuZGVjb3JhdGlvbnM7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRlY29yYXRpb24gPSBzZWxmLmRlY29yYXRpb25zLnNsaWNlKC0xKS5wb3AoKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIHJlc3VsdC53YXNfcHJvY2Vzc2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJvY2Vzc0NodW5rXG4gICAgICAgICAqIFByb2Nlc3NlcyB0aGUgY3VycmVudCBjaHVuayBvZiB0ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBwcm9jZXNzQ2h1bmtcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAgICAgICAgICpcbiAgICAgICAgICogIC0gYGpzb25gIChCb29sZWFuKTogSWYgYHRydWVgLCB0aGUgcmVzdWx0IHdpbGwgYmUgYW4gb2JqZWN0LlxuICAgICAgICAgKiAgLSBgdXNlX2NsYXNzZXNgIChCb29sZWFuKTogSWYgYHRydWVgLCBIVE1MIGNsYXNzZXMgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgSFRNTCBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFya3VwIElmIGZhbHNlLCB0aGUgY29sb3JzIHdpbGwgbm90IGJlIHBhcnNlZC5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fFN0cmluZ30gVGhlIHJlc3VsdCAob2JqZWN0IGlmIGBqc29uYCBpcyB3YW50ZWQgYmFjayBvciBzdHJpbmcgb3RoZXJ3aXNlKS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJwcm9jZXNzQ2h1bmtcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NDaHVuayh0ZXh0LCBvcHRpb25zLCBtYXJrdXApIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBqc29uQ2h1bmsgPSB0aGlzLnByb2Nlc3NDaHVua0pzb24odGV4dCwgb3B0aW9ucywgbWFya3VwKTtcbiAgICAgICAgICAgIHZhciB1c2VfY2xhc3NlcyA9IG9wdGlvbnMudXNlX2NsYXNzZXM7XG5cbiAgICAgICAgICAgIC8vIFwicmV2ZXJzZVwiIGRlY29yYXRpb24gcmV2ZXJzZXMgZm9yZWdyb3VuZCBhbmQgYmFja2dyb3VuZCBjb2xvcnNcbiAgICAgICAgICAgIGpzb25DaHVuay5kZWNvcmF0aW9ucyA9IGpzb25DaHVuay5kZWNvcmF0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGRlY29yYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVjb3JhdGlvbiA9PT0gXCJyZXZlcnNlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiByZXZlcnNpbmcsIG1pc3NpbmcgY29sb3JzIGFyZSBkZWZhdWx0ZWQgdG8gYmxhY2sgKGJnKSBhbmQgd2hpdGUgKGZnKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWpzb25DaHVuay5mZykge1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbkNodW5rLmZnID0gQU5TSV9DT0xPUlNbMF1bN11bdXNlX2NsYXNzZXMgPyBcImNsYXNzXCIgOiBcImNvbG9yXCJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghanNvbkNodW5rLmJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uQ2h1bmsuYmcgPSBBTlNJX0NPTE9SU1swXVswXVt1c2VfY2xhc3NlcyA/IFwiY2xhc3NcIiA6IFwiY29sb3JcIl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcEZnID0ganNvbkNodW5rLmZnO1xuICAgICAgICAgICAgICAgICAgICBqc29uQ2h1bmsuZmcgPSBqc29uQ2h1bmsuYmc7XG4gICAgICAgICAgICAgICAgICAgIGpzb25DaHVuay5iZyA9IHRtcEZnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wRmdUcnVlID0ganNvbkNodW5rLmZnX3RydWVjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAganNvbkNodW5rLmZnX3RydWVjb2xvciA9IGpzb25DaHVuay5iZ190cnVlY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGpzb25DaHVuay5iZ190cnVlY29sb3IgPSB0bXBGZ1RydWU7XG4gICAgICAgICAgICAgICAgICAgIGpzb25DaHVuay5pc0ludmVydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5qc29uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25DaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqc29uQ2h1bmsuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWpzb25DaHVuay53YXNfcHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25DaHVuay5jb250ZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29sb3JzID0gW107XG4gICAgICAgICAgICB2YXIgZGVjb3JhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHZhciB0ZXh0RGVjb3JhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBkYXRhID0ge307XG5cbiAgICAgICAgICAgIHZhciByZW5kZXJfZGF0YSA9IGZ1bmN0aW9uIHJlbmRlcl9kYXRhKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnRzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoKFwiZGF0YS1cIiArIGtleSArIFwiPVxcXCJcIiArIF90aGlzMi5lc2NhcGVGb3JIdG1sKGRhdGFba2V5XSkgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50cy5sZW5ndGggPiAwID8gXCIgXCIgKyBmcmFnbWVudHMuam9pbihcIiBcIikgOiBcIlwiO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGpzb25DaHVuay5pc0ludmVydGVkKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtcImFuc2ktaXMtaW52ZXJ0ZWRcIl0gPSBcInRydWVcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGpzb25DaHVuay5mZykge1xuICAgICAgICAgICAgICAgIGlmICh1c2VfY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcnMucHVzaChqc29uQ2h1bmsuZmcgKyBcIi1mZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25DaHVuay5mZ190cnVlY29sb3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbXCJhbnNpLXRydWVjb2xvci1mZ1wiXSA9IGpzb25DaHVuay5mZ190cnVlY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uQ2h1bmsuZmdfdHJ1ZWNvbG9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9ycy5wdXNoKFwiY29sb3I6cmdiKFwiICsganNvbkNodW5rLmZnICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGpzb25DaHVuay5iZykge1xuICAgICAgICAgICAgICAgIGlmICh1c2VfY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcnMucHVzaChqc29uQ2h1bmsuYmcgKyBcIi1iZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25DaHVuay5iZ190cnVlY29sb3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbXCJhbnNpLXRydWVjb2xvci1iZ1wiXSA9IGpzb25DaHVuay5iZ190cnVlY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uQ2h1bmsuYmdfdHJ1ZWNvbG9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9ycy5wdXNoKFwiYmFja2dyb3VuZC1jb2xvcjpyZ2IoXCIgKyBqc29uQ2h1bmsuYmcgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBqc29uQ2h1bmsuZGVjb3JhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZGVjb3JhdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBjbGFzc2VzXG4gICAgICAgICAgICAgICAgaWYgKHVzZV9jbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRpb25zLnB1c2goXCJhbnNpLVwiICsgZGVjb3JhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdXNlIHN0eWxlc1xuICAgICAgICAgICAgICAgIGlmIChkZWNvcmF0aW9uID09PSBcImJvbGRcIikge1xuICAgICAgICAgICAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKFwiZm9udC13ZWlnaHQ6Ym9sZFwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRlY29yYXRpb24gPT09IFwiZGltXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb3JhdGlvbnMucHVzaChcIm9wYWNpdHk6MC41XCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVjb3JhdGlvbiA9PT0gXCJpdGFsaWNcIikge1xuICAgICAgICAgICAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKFwiZm9udC1zdHlsZTppdGFsaWNcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZWNvcmF0aW9uID09PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRpb25zLnB1c2goXCJ2aXNpYmlsaXR5OmhpZGRlblwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRlY29yYXRpb24gPT09IFwic3RyaWtldGhyb3VnaFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHREZWNvcmF0aW9ucy5wdXNoKFwibGluZS10aHJvdWdoXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVuZGVybGluZSBhbmQgYmxpbmsgYXJlIHRyZWF0ZWQgaGVyZVxuICAgICAgICAgICAgICAgICAgICB0ZXh0RGVjb3JhdGlvbnMucHVzaChkZWNvcmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHRleHREZWNvcmF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKFwidGV4dC1kZWNvcmF0aW9uOlwiICsgdGV4dERlY29yYXRpb25zLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHVzZV9jbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiPHNwYW4gY2xhc3M9XFxcIlwiICsgY29sb3JzLmNvbmNhdChkZWNvcmF0aW9ucykuam9pbihcIiBcIikgKyBcIlxcXCJcIiArIHJlbmRlcl9kYXRhKGRhdGEpICsgXCI+XCIgKyBqc29uQ2h1bmsuY29udGVudCArIFwiPC9zcGFuPlwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCI8c3BhbiBzdHlsZT1cXFwiXCIgKyBjb2xvcnMuY29uY2F0KGRlY29yYXRpb25zKS5qb2luKFwiO1wiKSArIFwiXFxcIlwiICsgcmVuZGVyX2RhdGEoZGF0YSkgKyBcIj5cIiArIGpzb25DaHVuay5jb250ZW50ICsgXCI8L3NwYW4+XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJyZW1vdmVEZWNvcmF0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVEZWNvcmF0aW9uKGRlY29yYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuZGVjb3JhdGlvbnMuaW5kZXhPZihkZWNvcmF0aW9uKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQW5zZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQW5zZXI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/anser/lib/index.js\n");

/***/ })

};
;